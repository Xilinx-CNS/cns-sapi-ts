<?xml version="1.0" encoding="UTF-8"?>
<!-- SPDX-License-Identifier: Apache-2.0 -->
<!-- (c) Copyright 2004 - 2022 Xilinx, Inc. All rights reserved. -->
<test name="tcp" type="package">
  <objective>TCP protocol special cases</objective>
  <notes/>
  <iter result="PASSED">
    <notes/>
    <test name="connect_impossible" type="script">
      <objective>Check behaviour of connect() on socket of SOCK_STREAM type in case if server can not satisfy request or unreachable.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="check"/>
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_small_window" type="script">
      <objective>Check possibility of TCP data transfer when peer has small SO_RCVBUF (and, as result, announces small TCP window).</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="early"/>
        <arg name="env"/>
        <arg name="active"/>
        <arg name="tst_rcvbuf"/>
        <arg name="use_sendfile"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_zero_window" type="script">
      <objective>Check that zero window probes are made frequently enaugh</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="ip_fragments" type="script">
      <objective>Check that TCP messages splitted to more then one IP fragment will be processed by IUT TCP stack.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="frag_len"/>
        <notes/>
        <results tags="v5" key="OLDSW2V0-96" notes="Fragmented TCP/IP packets are not supported in V5.">
          <result value="FAILED">
            <verdict>Fragmented TCP packet was not received after a number of retransmissions</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="shutdown_fin" type="script">
      <objective>Check that FIN is sent write shutdown.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="shutdown_rst" type="script">
      <objective>Check the bahaivour after read shutdown and receiving of data from the peer.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="connect_nb_impossible" type="script">
      <objective>Check behaviour of various functions after unsatisfied connect().</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">connect</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">recv</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">select</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">getsockopt</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">EHOSTUNREACH</arg>
        <arg name="func">poll</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">connect</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">recv</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">select</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">getsockopt</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ECONNREFUSED</arg>
        <arg name="func">poll</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error"/>
        <arg name="func">od_send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error"/>
        <arg name="func">od_send_raw</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error"/>
        <arg name="func">template_send</arg>
        <notes/>
        <results tags="v5" notes="Function onload_msg_template_alloc() fails with errno ENOTCONN, it is SF extension API so it is ok">
          <result value="FAILED">
            <verdict>Function template_send() failed with unexpected errno: RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error"/>
        <arg name="func">onload_zc_send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error"/>
        <arg name="func">onload_zc_send_user_buf</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">connect</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">recv</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">select</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">getsockopt</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="error">ETIMEDOUT</arg>
        <arg name="func">poll</arg>
        <notes/>
      </iter>
    </test>
    <test name="connect_nb_impossible_icmp" type="script">
      <objective>Check behaviour of connect(), send(), recv(), select(), getsockopt(SO_ERROR) after ICMP message "destination unreachable" is received from server after connect().</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">connect</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">recv</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">recvmsg</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">onload_zc_recv</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">onload_zc_hlrx_recv_zc</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">onload_zc_hlrx_recv_copy</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">select</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">getsockopt</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">poll</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">template_send</arg>
        <notes/>
        <results tags="v5" key="ON-5054">
          <result value="FAILED">
            <verdict>Function template_send() failed with unexpected errno: RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">onload_zc_send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">onload_zc_send_user_buf</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">od_send</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="icmp_code"/>
        <arg name="func">od_send_raw</arg>
        <notes/>
      </iter>
    </test>
    <test name="packet_ack_drop" type="script">
      <objective/>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type"/>
        <arg name="test_retr_queue">TRUE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>Size of retransmition queue was reduced by changing SO_SNDBUF</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type">packet</arg>
        <arg name="test_retr_queue">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type">syn</arg>
        <arg name="test_retr_queue"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type">synack</arg>
        <arg name="test_retr_queue"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type">fin</arg>
        <arg name="test_retr_queue"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="pack_type">fin_close_wait</arg>
        <arg name="test_retr_queue"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_handle_rst" type="script">
      <objective>Check that socket in different TCP socket states processes packet with RST flag from peer correctly.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5&amp;!branch_ool1811" key="ON-9628" notes="Onload socket in FIN_WAIT2 state ignores RST segment with SEQN = next + 1 with data after close(), although linux accepts it">
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>bind() unexpectedly succeed with invalid SEQN in RST segment</verdict>
          </result>
        </results>
        <results tags="v5&amp;!branch_ool1811" key="ON-9628" notes="Onload socket in FIN_WAIT2 state ignores RST segment with SEQN = next + 1 with data after close(), although linux accepts it">
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux-4&gt;10" key="ON-9627" notes="It is expected behavior on Linux kernel 4.11 and above - https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/ipv4/tcp_input.c?id=0e40f4c9593ba2c7c30150ed669da97bd581c0cd">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-9627" notes="Onload behaves as Linux 4.11 and above">
          <result value="FAILED">
            <verdict>TCP socket is in TCP_CLOSE state after receiving invalid RST</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data">FALSE</arg>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data">FALSE</arg>
        <arg name="seqn_val">next-2</arg>
        <arg name="tcp_state"/>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_1</arg>
        <arg name="tcp_state"/>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next-2</arg>
        <arg name="tcp_state"/>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next_plus_maxoffs</arg>
        <arg name="tcp_state"/>
        <arg name="tst_type"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val">next</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="close_iut"/>
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="loopback"/>
        <arg name="send_data"/>
        <arg name="seqn_val"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>SO_ERROR socket option is equal to EPIPE, but must be ECONNRESET</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="shutdown_states" type="script">
      <objective>Check behaviour and effects of shutdown() call on TCP socket in different TCP states.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
        <results tags="linux&amp;zf_shim" notes="ZF determines TCP_TIME_WAIT state">
          <result value="PASSED">
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_TIME_WAIT</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
        <results tags="linux&amp;zf_shim" notes="ZF determines TCP_TIME_WAIT state">
          <result value="PASSED">
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_TIME_WAIT</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSING</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSING</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="FAILED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_ESTABLISHED</verdict>
            <verdict>send() returned length of data to be sent</verdict>
            <verdict>Data sent after shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE_WAIT</verdict>
            <verdict>send() returned length of data to be sent</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>TCP_TIME_WAIT is not observable</verdict>
            <verdict>shutdown() failed with errno ENOTCONN</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSING</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_ESTABLISHED</verdict>
            <verdict>send() returned length of data to be sent</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before">TRUE</arg>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE_WAIT</verdict>
            <verdict>send() returned length of data to be sent</verdict>
            <verdict>Data send before shutdown(RD) call was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT2</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_send_after">TRUE</arg>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LAST_ACK</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before">FALSE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before">TRUE</arg>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_SYN_RECV</verdict>
            <verdict>send() failed with errno EAGAIN</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_SYN_RECV</verdict>
            <verdict>send() failed with errno EAGAIN</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_LISTEN</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_LISTEN</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-1362">
          <result value="FAILED">
            <verdict>TCP_SYN_RECV was not achieved</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
        <results tags="zf_shim" key="ST-757">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
            <verdict>Second connect() call after shutdown() sucesseed</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_FIN_WAIT1</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-1362">
          <result value="FAILED">
            <verdict>TCP_SYN_RECV was not achieved</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_WR</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
        <results tags="zf_shim" key="ST-757">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno EAGAIN</verdict>
            <verdict>Second connect() call after shutdown() sucesseed</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_LISTEN</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno EPIPE</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_SYN_RECV</verdict>
            <verdict>send() failed with errno EAGAIN</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-1362">
          <result value="FAILED">
            <verdict>TCP_SYN_RECV was not achieved</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_SYN_RECV</verdict>
            <verdict>send() failed with errno EAGAIN</verdict>
            <verdict>recv() returned 0</verdict>
          </result>
        </results>
        <results tags="v5" key="ON-1362">
          <result value="FAILED">
            <verdict>TCP_SYN_RECV was not achieved</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how">SHUT_RD</arg>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="iut_send_before"/>
        <arg name="loopback"/>
        <arg name="shutdown_how"/>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="tst_send_after"/>
        <arg name="tst_send_before"/>
        <arg name="tst_type"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>shutdown() successed</verdict>
            <verdict>After shutdown() call TCP state is TCP_CLOSE</verdict>
            <verdict>send() failed with errno ECONNRESET</verdict>
            <verdict>recv() failed with errno ENOTCONN</verdict>
            <verdict>Second connect() call after shutdown() failed with errno EINPROGRESS</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="tcp_loopback" type="script">
      <objective>Check that we can connect two TCP sockets created on the same host no matter which addresses on which interfaces they are bound to.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5&amp;!(reuse_stack)">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">2</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(v5&amp;!reuse_stack))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">4</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">SFC_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_BOTH</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">1</arg>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">3</arg>
        <arg name="ef_tcp_server_loopback">0</arg>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">OTH_LO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr">NO_ADDR</arg>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">2</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_CONN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback">1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">SAME_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">0</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">ROOT_LISTEN</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr"/>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users">DIFF_USERS</arg>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first"/>
        <arg name="client_addr"/>
        <arg name="connect_addr">WILD_ADDR</arg>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">FALSE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback">-1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">FALSE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback">-1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">FALSE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">-1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">FALSE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback">-1</arg>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">TRUE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">SFC_ADDR</arg>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">TRUE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_ADDR</arg>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">TRUE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="accept_first">TRUE</arg>
        <arg name="client_addr"/>
        <arg name="connect_addr">OTH_LO_ADDR</arg>
        <arg name="ef_tcp_client_loopback"/>
        <arg name="ef_tcp_server_loopback"/>
        <arg name="env"/>
        <arg name="loopback_users"/>
        <arg name="server_addr"/>
        <arg name="v6only">FALSE</arg>
        <notes/>
        <results tags="linux&amp;(!v5|(ool_loop=0))">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="non_accepted_closed" type="script">
      <objective>Check behaviour of accept() when socket to be returned by it received RST or FIN from peer already and then close() or shutdown (RD) was called on listening socket</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_close">TRUE</arg>
        <arg name="tst_close"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>accept() failed with errno EBADF</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iut_close">FALSE</arg>
        <arg name="tst_close"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>accept() failed with errno EINVAL</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="syn_recv_fin_wait1" type="script">
      <objective>Check that when we close (or call shutdown(RD)) on a listening socket just received SYN it will send TCP FIN or RST to a peer.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="use_shutdown"/>
        <arg name="so_reuseaddr"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>connect() call returned errno ECONNREFUSED</verdict>
            <verdict>Message with RST flag set was received</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="out_of_socks_tcp_loopback" type="script">
      <objective>Check that TCP loopback connection is accelerated when all TCP accelerated sockets are opened and 1/2/3 socket are closed after this.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="conn_stack">TRUE</arg>
        <arg name="env"/>
        <arg name="sock_close_num">3</arg>
        <notes/>
        <results tags="v5&amp;(ool_loop=0)|!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="conn_stack">TRUE</arg>
        <arg name="env"/>
        <arg name="sock_close_num">1</arg>
        <notes/>
        <results tags="v5&amp;(ool_loop=3|ool_loop=4)" key="ON-4656">
          <result value="FAILED" key="ON-4656">
            <verdict>connect() failed with EMFILE</verdict>
          </result>
        </results>
        <results tags="v5&amp;(ool_loop=0)|!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="conn_stack">FALSE</arg>
        <arg name="env"/>
        <arg name="sock_close_num">3</arg>
        <notes/>
        <results tags="v5&amp;(ool_loop=0)|!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
        <results tags="v5&amp;(ool_loop=2|ool_loop=4|(ool_loop=1&amp;reuse_stack))">
          <result value="PASSED"/>
          <result value="FAILED" key="ON-4656">
            <verdict>accept() failed with EMFILE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="conn_stack">FALSE</arg>
        <arg name="env"/>
        <arg name="sock_close_num">1</arg>
        <notes/>
        <results tags="v5&amp;(ool_loop=0)|!v5">
          <result value="PASSED">
            <verdict>CSAP registered data traffic on the loopback interface</verdict>
          </result>
        </results>
        <results tags="v5&amp;default_iomux_epoll&amp;!(ool_loop=2|ool_loop=4)" key="ST-1867" notes="Expected behavior for epoll. Onload opens more than one fd per epoll set.">
          <result value="FAILED">
            <verdict>Data was sent but peer socket is not readable</verdict>
          </result>
        </results>
        <results tags="v5&amp;(ool_loop=2|ool_loop=4|(ool_loop=1&amp;reuse_stack&amp;!default_iomux_epoll))">
          <result value="PASSED"/>
          <result value="FAILED" key="ON-4656">
            <verdict>accept() failed with EMFILE</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="tcp_flooder_mult" type="script">
      <objective>Stress test for loopback with bidirectional data transmission.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="iterations"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED"/>
          <result value="FAILED" key="ST-2107" notes="Test fails if kernel does not support net/ipv4/tcp_syncookies">
            <verdict>Failed to enable tcp_syncookies (CS-ENOENT)</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="tcp_timeout" type="script">
      <objective>Check that the socket will be eventually dropped to TCP_CLOSED because of retransmit timeout if it does not receive replies.</objective>
      <notes>Tests may fail in some virtualised environments. For this case the tcpi_probes must be equal 0.</notes>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="mode"/>
        <arg name="opening"/>
        <arg name="cache_socket"/>
        <arg name="tcp_state"/>
        <arg name="data_packet"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_state_hang" type="script">
      <objective>Check that socket cannot hang in TCP_SYN_RECV, TCP_CLOSING, TCP_LAST_ACK or TCP_FIN_WAIT1 due to receiving an ACK with incorrect sequence number</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_close</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-2^31+1</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">active</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening">passive_open</arg>
        <arg name="seqn">last_seqn-random</arg>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="seqn"/>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="opening"/>
        <arg name="seqn"/>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_LAST_ACK to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_CLOSING to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_FIN_WAIT1 to TCP_FIN_WAIT2</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="opening"/>
        <arg name="seqn"/>
        <arg name="tcp_state"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_LAST_ACK to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_CLOSING to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="opening"/>
        <arg name="seqn">last_seqn</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-3928">
          <result value="PASSED">
            <verdict>Sending ACK with incorrect sequence number resulted in changing TCP state from TCP_FIN_WAIT1 to TCP_FIN_WAIT2</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="listen_backlog_max" type="script">
      <objective>Test listen backlog maximum with a lot of half-opened connections.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="backlog_max">50</arg>
        <arg name="completed_conns_num"/>
        <arg name="env"/>
        <arg name="ef_prefault_packets"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="backlog_max">100000</arg>
        <arg name="completed_conns_num"/>
        <arg name="env"/>
        <arg name="ef_prefault_packets"/>
        <notes/>
        <results tags="linux&amp;!v5" notes="Pure linux behaves in this way here for unknown reasons">
          <result value="FAILED">
            <verdict>Too small number of SYN-ACKS was received</verdict>
            <verdict>Too small number of connections was accepted</verdict>
            <verdict>Some connections were reset</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="tcp_zero_window_ext" type="script">
      <objective>Check that TCP socket closes properly despite it received a packet with the zero window.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="cache_socket"/>
        <arg name="data_packet_ack"/>
        <arg name="env"/>
        <arg name="handshake"/>
        <arg name="linger"/>
        <arg name="shut"/>
        <arg name="overfill_sndbuf"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_small_segment" type="script">
      <objective>Check that after receiving too many 1-byte packets on one connection new connection can be created and works properly.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo</arg>
        <arg name="active"/>
        <arg name="recv_loops"/>
        <arg name="with_holes">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_lo_ipv6</arg>
        <arg name="active"/>
        <arg name="recv_loops"/>
        <arg name="with_holes">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="active"/>
        <arg name="recv_loops"/>
        <arg name="with_holes">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="active"/>
        <arg name="recv_loops"/>
        <arg name="with_holes">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="active"/>
        <arg name="recv_loops"/>
        <arg name="with_holes">TRUE</arg>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_window_update" type="script">
      <objective/>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="fin_out_of_window" type="script">
      <objective>Check what happens when peer sends data until TCP window is filled, and in the last packet FIN flag is set.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_close_timeout" type="script">
      <objective>Check that TCP connection is closed properly by timeouts if not attached to UL.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="kill"/>
        <arg name="linger"/>
        <arg name="opening"/>
        <arg name="retries"/>
        <arg name="tcp_fin_timeout"/>
        <arg name="tcp_state"/>
        <notes/>
        <results tags="linux" key="ST-2567">
          <result value="PASSED"/>
          <result value="PASSED">
            <verdict>Amount of sent FIN-ACK packets are lower than amount of expected ones by ONE packet</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="syn_ack_distrib" type="script">
      <objective/>
      <notes/>
      <iter result="PASSED">
        <arg name="delay"/>
        <arg name="env"/>
        <arg name="max_intersects"/>
        <arg name="syn_num"/>
        <notes/>
      </iter>
    </test>
    <test name="initial_rto" type="script">
      <objective>Compair delays between initial SYN-ACK and SYN retransmits</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="prologue_timeouts_init" type="script">
      <objective>Prologue to tweak TCP timeouts</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="closing_time_wait" type="script">
      <objective>Close TCP socket while it is in TIME_WAIT state.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="opening"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="listener_closing_states" type="script">
      <objective>Check that closing listener socket does not violate accepted socket behavior independently on its state.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
    </test>
    <test name="fin_data" type="script">
      <objective>Exercise FIN packet processing with data in various situations</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger"/>
        <arg name="shutdown"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_fork_distrib" type="script">
      <objective>Check that the child and parent accept more-or-less the same number of connection requests.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="num"/>
        <arg name="thread"/>
        <notes/>
        <results tags="v5" key="ON-4129">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much difference in accepted connections between processes</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="close_no_ack" type="script">
      <objective>Check that connection is closed correct despite broken connectivity.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close">FALSE</arg>
        <arg name="way">shutdown</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close">FALSE</arg>
        <arg name="way">shutdown</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close">TRUE</arg>
        <arg name="way"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close">TRUE</arg>
        <arg name="way"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">0</arg>
        <arg name="shutdown_close"/>
        <arg name="way"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">1</arg>
        <arg name="shutdown_close"/>
        <arg name="way"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close"/>
        <arg name="way">close</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close"/>
        <arg name="way">exit</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close"/>
        <arg name="way">kill</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">-1</arg>
        <arg name="shutdown_close"/>
        <arg name="way">dup2</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close"/>
        <arg name="way">close</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close"/>
        <arg name="way">exit</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close"/>
        <arg name="way">kill</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="linger">7</arg>
        <arg name="shutdown_close"/>
        <arg name="way">dup2</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" key="ST-612" notes="Linux can send few more FIN-ACKs the it is specified">
          <result value="PASSED">
            <verdict>Unexpected number of FIN-ACK packets were caught: 6 instead of 4</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="shutdown_data" type="script">
      <objective>Check data packet coming after calling shutdown is handled proerly.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="no_ack"/>
        <arg name="shut"/>
        <arg name="active"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="default_tcp_orphan_retries" type="script">
      <objective>Check that default FIN-ACK retransmit number in Onload is equal to linux number.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
    </test>
    <test name="peer_large_window" type="script">
      <objective>Check that declared large window with unacknowledged data does not make harm for the send queue.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="ack">FALSE</arg>
        <arg name="cache_socket">TRUE</arg>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">-1</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
        <results tags="linux" notes="Linux automatically increases send buffer to a large value here">
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack">FALSE</arg>
        <arg name="cache_socket">FALSE</arg>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">-1</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
        <results tags="linux&amp;!zf_shim" notes="Linux automatically increases send buffer to a large value here">
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
        <results tags="linux&amp;zf_shim" notes="TCP zocket has a constant send buffer size">
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack">TRUE</arg>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf"/>
        <arg name="sndbuf_mode"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
        <results tags="linux" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode"/>
        <notes/>
        <results tags="linux" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode">0</arg>
        <notes/>
        <results tags="v5" key="ON-4228" notes="It is expected behavior for EF_TCP_SNDBUF_MODE=0, see bug 47197 for details">
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">TRUE</arg>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">5000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket">TRUE</arg>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode">-1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf">150000</arg>
        <arg name="sndbuf_mode">0</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf"/>
        <arg name="sndbuf_mode">1</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="rcvbuf"/>
        <arg name="sndbuf"/>
        <arg name="sndbuf_mode">2</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Linux automatically increases send buffer to a large value here">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Too much data was successfully written to socket</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="tcp_last_data" type="script">
      <objective>Check the behaviour of tcp_info struct fields: tcpi_last_data_recv, tcpi_last_data_sent and tcpi_last_ack_recv.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-5714">
          <result value="FAILED">
            <verdict>Unexpected value of tcpi_last_data_sent (0), expected 2181</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="connect_impossible_icmp" type="script">
      <objective>Check connect() call behaviour when ICMP message "destination unreachable" is received from the peer.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">oo_epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">oo_epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">select</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">pselect</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">poll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">ppoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll_pwait</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">select</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">pselect</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">poll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">ppoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer_ipv6</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll_pwait</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">oo_epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">oo_epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">select</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">pselect</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">poll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">ppoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">TRUE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll_pwait</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="PASSED">
            <verdict>recvmsg() failed with unexpected errno RPC-ENOTCONN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">select</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">pselect</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">poll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">ppoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="blocking">FALSE</arg>
        <arg name="env">VAR.env.peer2peer</arg>
        <arg name="error_code"/>
        <arg name="iomux">epoll_pwait</arg>
        <arg name="select_err_queue"/>
        <notes/>
        <results tags="v5|(linux&lt;3|linux=3&amp;linux-3&lt;17)" key="ON-5444">
          <result value="FAILED">
            <verdict>recvmsg() failed with ICMP errno</verdict>
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
        <results tags="!v5&amp;(linux=3&amp;linux-3&gt;=17|linux=4&amp;linux-4&lt;11)">
          <result value="FAILED">
            <verdict>send(): unexpected errno RPC-EPIPE was reported</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="connection_timeout_data" type="script">
      <objective>Check data located in receive buffer can be read after the connection drop by retransmits.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="overfill_close" type="script">
      <objective>Overfill send or receive buffer and close the socket.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="shutdown"/>
        <arg name="fill_rcv"/>
        <arg name="fill_snd"/>
        <arg name="peer_close"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="syn_sent_func" type="script">
      <objective>Check socket functions behavior in SYN-SENT state.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="nonblock"/>
        <arg name="test_func"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="syn_recv_peer_shutdown" type="script">
      <objective>In human language: http client comes to the server with a short request. ACK from 3-way handshake is lost. The server must handle the http request properly, and reply with the html page content.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="epoll"/>
        <arg name="shutdown"/>
        <notes/>
      </iter>
    </test>
    <test name="close_send_buf" type="script">
      <objective/>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="full"/>
        <notes/>
      </iter>
    </test>
    <test name="send_block_unblock" type="script">
      <objective>Check that a process is blocked in send call when buffers are full and unblocked as soon there is enough space in send buffer.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="sock_type"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="close_send_buf_no_ack" type="script">
      <objective>Check that socket can be correctly closed despite there is sent data which is not ACKed.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="close"/>
        <arg name="env"/>
        <arg name="shut_tst"/>
        <arg name="sock_type"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="recv_unblock_fin" type="script">
      <objective>Check that blocking read or iomux call is unblocked when FIN is arrived and it is not unblocked by ACK.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="block_read">TRUE</arg>
        <arg name="env"/>
        <arg name="iomux_type"/>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">select</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">pselect</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">poll</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
        <results tags="v5&amp;ool_spin" key="ON-8231" notes="Race condition, see also ST-2354.">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Unexpected events EVT_RD instead of EVT_RD | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
          <result value="FAILED">
            <verdict>Unexpected events EVT_WR instead of EVT_RD | EVT_WR | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">ppoll</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
        <results tags="v5&amp;ool_spin" key="ON-8231" notes="Race condition, see also ST-2354.">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Unexpected events EVT_RD instead of EVT_RD | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
          <result value="FAILED">
            <verdict>Unexpected events EVT_WR instead of EVT_RD | EVT_WR | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">epoll</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
        <results tags="v5&amp;ool_spin" key="ON-8231" notes="Race condition, see also ST-2354.">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Unexpected events EVT_RD instead of EVT_RD | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
          <result value="FAILED">
            <verdict>Unexpected events EVT_WR instead of EVT_RD | EVT_WR | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="block_read">FALSE</arg>
        <arg name="env"/>
        <arg name="iomux_type">epoll_pwait</arg>
        <arg name="out"/>
        <arg name="sock_type"/>
        <arg name="tst_packet"/>
        <notes/>
        <results tags="v5&amp;ool_spin" key="ON-8231" notes="Race condition, see also ST-2354.">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>Unexpected events EVT_RD instead of EVT_RD | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
          <result value="FAILED">
            <verdict>Unexpected events EVT_WR instead of EVT_RD | EVT_WR | EVT_EXC | EVT_HUP after connection repair</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="invalid_ack" type="script">
      <objective>Check that invalid ACK is processed correctly and the connection can continue work without deviations.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="bad_seqn"/>
        <arg name="cache_socket"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="tcp_state"/>
        <arg name="timestamp"/>
        <arg name="value"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_cork_vs_nodelay" type="script">
      <objective>Send data when various combinations of options TCP_NODELAY and TCP_CORK are used, check that both options can be used to trigger data transmission.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="nonblock"/>
        <arg name="packets_num"/>
        <arg name="send_data_before"/>
        <arg name="send_nodelay"/>
        <arg name="send_usleep"/>
        <arg name="size_max"/>
        <arg name="size_min"/>
        <arg name="sock_type"/>
        <arg name="tcp_nodelay_before"/>
        <notes/>
      </iter>
    </test>
    <test name="connect_shutdown_connect" type="script">
      <objective>Abort connection attemt using shutdown(wr) while it is in progress, then connect the same socket to the peer.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst">TRUE</arg>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst">FALSE</arg>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst">TRUE</arg>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_tst_gw_ipv6</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst">FALSE</arg>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock">TRUE</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-6874">
          <result value="FAILED">
            <verdict>The second connect() returned unexpected errno RPC-ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-6874">
          <result value="FAILED">
            <verdict>The final connect() failed with errno RPC-ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock">TRUE</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-6874">
          <result value="FAILED">
            <verdict>The second connect() returned unexpected errno RPC-ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="first_nonblock">TRUE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock">FALSE</arg>
        <arg name="cache_socket"/>
        <notes/>
        <results tags="v5" key="ON-6874">
          <result value="FAILED">
            <verdict>The final connect() failed with errno RPC-ECONNRESET</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env">VAR.env.peer2peer_gw_ipv6</arg>
        <arg name="first_nonblock">FALSE</arg>
        <arg name="rst"/>
        <arg name="second_nonblock"/>
        <arg name="cache_socket"/>
        <notes/>
      </iter>
    </test>
    <test name="many_listeners" type="script">
      <objective>Create a lot of listener sockets using scalable filters and accept connections on them.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="cluster_ignore"/>
        <notes/>
      </iter>
    </test>
    <test name="rtt_calc" type="script">
      <objective>Compare the difference between the calculated RTO and the RTO obtained during the retransmit process.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="passive_open"/>
        <arg name="send_aux_data"/>
        <arg name="iut_timestamps_enable"/>
        <arg name="tst_timestamps_enable"/>
        <notes/>
      </iter>
    </test>
    <test name="last_ack_connect" type="script">
      <objective>Check that a new connection can be accepted when a socket from the previous one is still in LAST_ACK state.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="active">TRUE</arg>
        <notes/>
        <results tags="linux&amp;zf_shim" notes="ZF shim shows TCP_TIME_WAIT state after tx shutdown and returns EINPROGRESS errno instead EALREADY">
          <result value="PASSED">
            <verdict>Client socket is observed in TCP_TIME_WAIT state, but should be in TCP_CLOSE</verdict>
            <verdict>Nonblocking connect() failed with unexpected errno RPC-EINPROGRESS when called the second time</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="active">FALSE</arg>
        <notes/>
      </iter>
    </test>
    <test name="syn_sent_fin_ack" type="script">
      <objective>Check that when a socket in SYN_SENT state receives FIN-ACK from a previous connection, it answers with RST.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="last_ack_recv_pkt" type="script">
      <objective>Check how LAST_ACK state handles various incoming packets.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="enable_timestamps"/>
        <arg name="env"/>
        <arg name="send_syn">TRUE</arg>
        <arg name="seqn_mod"/>
        <arg name="sock_type"/>
        <arg name="ts_echo_mod"/>
        <arg name="ts_value_mod"/>
        <notes/>
        <results tags="linux">
          <result value="PASSED">
            <verdict>IUT responded with TCP packet having flags [ ACK ] with updated SEQN</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="enable_timestamps"/>
        <arg name="env"/>
        <arg name="send_syn">FALSE</arg>
        <arg name="seqn_mod"/>
        <arg name="sock_type"/>
        <arg name="ts_echo_mod"/>
        <arg name="ts_value_mod"/>
        <notes/>
      </iter>
    </test>
    <test name="tsa_gw_prologue" type="script">
      <objective>Prologue to configure gateway for CSAP_GW mode in TSA library.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="ts_recv_values" type="script">
      <objective>Check what happens after receiving a packet with various timestamp values.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="linux&amp;!v5" key="ST-1296">
          <result value="FAILED">
            <verdict>Failed to catch expected retransmits from IUT socket at the end</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="linux&amp;!v5" key="ST-1296">
          <result value="FAILED">
            <verdict>Failed to catch expected retransmits from IUT socket at the end</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="linux&amp;!v5" key="ST-1296">
          <result value="FAILED">
            <verdict>IUT listener was readable after receiving packet with wrong timestamp</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE instead of TCP_FIN_WAIT2</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSING instead of TCP_FIN_WAIT1</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE_WAIT instead of TCP_ESTABLISHED</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE instead of TCP_FIN_WAIT2</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSING instead of TCP_FIN_WAIT1</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE_WAIT instead of TCP_ESTABLISHED</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">FIN.ACKPrev</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">FIN.ACKCur</arg>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">1</arg>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts">0xffffd8ef</arg>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">none</arg>
        <arg name="test_ts"/>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE instead of TCP_FIN_WAIT2</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSING instead of TCP_FIN_WAIT1</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data">FALSE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE_WAIT instead of TCP_ESTABLISHED</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE instead of TCP_FIN_WAIT2</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSING instead of TCP_FIN_WAIT1</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data">TRUE</arg>
        <arg name="test_flags">FIN</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>After receiving a test packet socket is in TCP_CLOSE_WAIT instead of TCP_ESTABLISHED</verdict>
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="test_data"/>
        <arg name="test_flags">RST.ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">FIN.ACKPrev</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">FIN.ACKCur</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="test_data"/>
        <arg name="test_flags"/>
        <arg name="test_ts">-1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="start_ts"/>
        <arg name="tcp_state"/>
        <arg name="test_data"/>
        <arg name="test_flags">none</arg>
        <arg name="test_ts">-1</arg>
        <notes/>
        <results tags="v5" key="ON-9322">
          <result value="FAILED">
            <verdict>recv() on IUT passed after receiving a packet which should have been ignored</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="timestamps_prologue" type="script">
      <objective>Prologue used to enable or disable timestamps for a group of iterations.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="enable_timestamps"/>
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="timestamps_epilogue" type="script">
      <objective>Epilogue used to restore original IUT timestamps state after timestamps_prologue.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="../gateways_epilogue" type="script">
      <objective>Epilogue used to reset interfaces after different gateway settings.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="syn_ack_ts_corrupted" type="script">
      <objective>Check what happens if timestamp is lost in SYN-ACK due to packet corruption.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="syn_bad_addr" type="script">
      <objective>Send from tester SYN with incorrect source address and check that IUT drops it</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="tst_src_addr_type"/>
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_handle_syn" type="script">
      <objective>Check that socket in different TCP socket states processes packet with SYN flag from peer correctly.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
        <results tags="linux&amp;!zf_shim" key="ST-1637">
          <result value="FAILED">
            <verdict>TCP_TIME_WAIT: IUT socket unexpectedly changed its state to TCP_SYN_RECV</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
        <results tags="linux&amp;!zf_shim" key="ST-1637">
          <result value="FAILED">
            <verdict>TCP_TIME_WAIT: IUT socket unexpectedly changed its state to TCP_SYN_RECV</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" notes="Linux behavior">
          <result value="FAILED">
            <verdict>TCP_FIN_WAIT2: IUT socket unexpectedly changed its state to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
        <results tags="linux&amp;!v5&amp;!zf_shim" notes="Linux behavior">
          <result value="FAILED">
            <verdict>TCP_FIN_WAIT2: IUT socket unexpectedly changed its state to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
    </test>
    <test name="tcp_handle_fin" type="script">
      <objective>Check that incorrect FIN packet is processed correctly in various TCP states</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
        <results tags="linux" key="ST-1599" notes="Linux behavior">
          <result value="PASSED">
            <verdict>IUT did not send ACK after data was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
        <results tags="linux" key="ST-1599" notes="Linux behavior">
          <result value="PASSED">
            <verdict>IUT did not send ACK after data was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
        <results tags="v5" key="ON-10824" notes="This behavior is acceptable in TCP_FIN_WAIT2 state after close() call">
          <result value="FAILED">
            <verdict>IUT did not send ACK after data was received</verdict>
            <verdict>IUT sent RST segment after data was received</verdict>
            <verdict>TCP_FIN_WAIT2: IUT socket unexpectedly changed its state to TCP_CLOSE after data was received</verdict>
          </result>
        </results>
        <results tags="linux&amp;!v5" key="ST-1599" notes="Linux behavior">
          <result value="FAILED">
            <verdict>TCP_FIN_WAIT2: IUT socket unexpectedly changed its state to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
        <results tags="linux&amp;!v5" key="ON-10824" notes="Onload is resistant to blind FIN attack, unlike Linux.">
          <result value="FAILED">
            <verdict>TCP_FIN_WAIT2: IUT socket unexpectedly changed its state to TCP_CLOSE</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
        <results tags="linux" key="ST-1599" notes="Linux behavior">
          <result value="FAILED">
            <verdict>IUT did not send ACK after data was received</verdict>
            <verdict>IUT sent RST segment after data was received</verdict>
            <verdict>TCP_FIN_WAIT1: IUT socket unexpectedly changed its state to TCP_CLOSE after data was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <notes/>
        <results tags="linux&amp;!v5" key="ON-10824" notes="Onload differs from Linux">
          <result value="PASSED">
            <verdict>IUT did not send ACK after data was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut">FALSE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">max_offs</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">max_offs</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut">TRUE</arg>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">max_offs</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val"/>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">max_offs</arg>
        <arg name="tcp_state"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_datalen</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
        <results tags="linux&amp;!v5" key="ON-10824" notes="Onload differs from Linux">
          <result value="PASSED">
            <verdict>IUT did not send challenge ACK before data was received</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next-1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
        <results tags="linux&amp;!v5" key="ON-10824" notes="Onload differs from Linux">
          <result value="PASSED">
            <verdict>IUT did not send challenge ACK</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_val">next_plus_1</arg>
        <arg name="active"/>
        <arg name="close_iut"/>
        <arg name="env"/>
        <arg name="pass_data"/>
        <arg name="seq_val">next_plus_1</arg>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <notes/>
        <results tags="linux&amp;!v5" key="ON-10824" notes="Onload differs from Linux">
          <result value="PASSED">
            <verdict>IUT did not send challenge ACK</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="same_tuple_new_isn" type="script">
      <objective>Check that if after closing of established TCP connection a new TCP connection with the same local and remote address/port is established actively from IUT, its ISN is chosen to be greater than the last SEQN from the previous connection.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="first_active"/>
        <arg name="send_data">TRUE</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="Whether we outrun Linux ISN counter depends on network interface speed (10 MB/s is too slow), we do not have tags for that. So results are not stable here.">
          <result value="PASSED"/>
          <result value="FAILED">
            <verdict>ISN of the second connection is not greater than the last SEQN of the first connection</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="first_active"/>
        <arg name="send_data">FALSE</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="On Linux ISN counter increments every 64 ns, so the period for TCP ISN is less than 275 seconds">
          <result value="PASSED">
            <verdict>ISN counter will wrap in less than 480 seconds</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="diff_tuple_diff_isn" type="script">
      <objective>Check that for TCP connections with different addresses/ports substantially different TCP ISNs are selected.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">none</arg>
        <arg name="env"/>
        <arg name="server_diff">addr</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="client_diff">none</arg>
        <arg name="env"/>
        <arg name="server_diff">port</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">no_bind</arg>
        <arg name="env"/>
        <arg name="server_diff">addr</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="client_diff">addr</arg>
        <arg name="env"/>
        <arg name="server_diff">none</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">port</arg>
        <arg name="env"/>
        <arg name="server_diff">none</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">no_bind</arg>
        <arg name="env"/>
        <arg name="server_diff">none</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="client_diff">addr</arg>
        <arg name="env"/>
        <arg name="server_diff">port</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="client_diff">port</arg>
        <arg name="env"/>
        <arg name="server_diff">addr</arg>
        <notes/>
        <results tags="v5" key="ON-10714">
          <result value="FAILED">
            <verdict>Too many connections have close values of ISN</verdict>
          </result>
          <result value="PASSED"/>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="client_diff">none</arg>
        <arg name="env"/>
        <arg name="server_diff">addr</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">none</arg>
        <arg name="env"/>
        <arg name="server_diff">port</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">no_bind</arg>
        <arg name="env"/>
        <arg name="server_diff">port</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">TRUE</arg>
        <arg name="client_diff">addr</arg>
        <arg name="env"/>
        <arg name="server_diff">none</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="client_diff">port</arg>
        <arg name="env"/>
        <arg name="server_diff">none</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="client_diff">addr</arg>
        <arg name="env"/>
        <arg name="server_diff">addr</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active"/>
        <arg name="client_diff">port</arg>
        <arg name="env"/>
        <arg name="server_diff">port</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="active">FALSE</arg>
        <arg name="client_diff">no_bind</arg>
        <arg name="env"/>
        <arg name="server_diff"/>
        <notes/>
      </iter>
    </test>
    <test name="overfill_shutdown_reduce_pmtu" type="script" pos="67">
      <objective>Check what happens when after overfilling send buffer shutdown(SHUT_RDWR) is called on IUT socket, then MTU on IUT interface is reduced, then peer socket on Tester tries to read all the data.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="syn_resend" type="script">
      <objective>Check that listening socket accepts a re-send of a SYN segment</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
      </iter>
    </test>
    <test name="zero_window_after_shrink" type="script">
      <objective>Check that data is retransmitted when window becomes non-zero after shrink.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="active"/>
        <arg name="close_iut_s"/>
        <arg name="set_zero"/>
        <arg name="cache_socket"/>
        <arg name="packets_before"/>
        <notes/>
      </iter>
    </test>
    <test name="fit_window_after_shrink" type="script">
      <objective>Check that data fits into recently shrinked window.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="active"/>
        <arg name="cache_socket"/>
        <arg name="packets_num"/>
        <arg name="packets_wo_ack"/>
        <notes/>
      </iter>
    </test>
    <test name="ack_out_of_window" type="script">
      <objective>Check that space is freed in send queue when ACK is received in a TCP packet retransmit which spans the end of TCP window.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <notes/>
        <results tags="v5" key="ON-12735">
          <result value="PASSED">
            <verdict>Packet sent to IUT was partially acknowledged due to small window</verdict>
          </result>
        </results>
        <results tags="zf_shim" key="ON-12877" notes="See also ON-12735">
          <result value="FAILED">
            <verdict>IUT socket is not writable after sending ACKs in retransmitted packets</verdict>
          </result>
        </results>
      </iter>
    </test>
    <test name="ts_send" type="script">
      <objective>Check that if TCP timestamps are enabled, all the packets sent from IUT (including ACKs) contain this option.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="sock_type"/>
        <arg name="passive_close"/>
      </iter>
    </test>
    <test name="close_linger" type="script">
      <objective>Check that tcp socket will be closed according to SO_LINGER socket option.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before">FALSE</arg>
        <arg name="single_sock">FALSE</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="linux" notes="SYN_RECV remains hanging after closing listener on Linux and on Onload in case of non-zero linger">
          <result value="PASSED">
            <verdict>Socket disappeared unexpectedly after closing</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before">TRUE</arg>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="linux" notes="SYN_RECV remains hanging after closing listener on Linux and on Onload in case of non-zero linger">
          <result value="PASSED">
            <verdict>Socket disappeared unexpectedly after closing</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock">TRUE</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
        <results tags="linux&amp;!v5" notes="SYN_RECV remains hanging after closing listener on Linux">
          <result value="PASSED">
            <verdict>Socket should disappear after closing, but it is instead in TCP_SYN_RECV state</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock">TRUE</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;linux" key="ON-12859">
          <result value="PASSED">
            <verdict>Socket disappeared unexpectedly after closing</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before">FALSE</arg>
        <arg name="single_sock">FALSE</arg>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before">TRUE</arg>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_SYN_RECV</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_SYN_SENT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close"/>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_FIN_WAIT2</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger"/>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger"/>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">instant</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_TIME_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">delayed</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_ESTABLISHED</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSE_WAIT</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_FIN_WAIT1</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_CLOSING</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way"/>
        <arg name="zero_linger">TRUE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">close</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">exit</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">kill</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
        <results tags="v5&amp;rss_scalable_active_passive" key="ON-13038">
          <result value="FAILED">
            <verdict>IUT address is free when it should be in use</verdict>
          </result>
        </results>
      </iter>
      <iter result="PASSED">
        <arg name="ack_after_close">none</arg>
        <arg name="env"/>
        <arg name="opening"/>
        <arg name="set_before"/>
        <arg name="single_sock"/>
        <arg name="tcp_state">TCP_LAST_ACK</arg>
        <arg name="unacked_data"/>
        <arg name="use_fork"/>
        <arg name="way">dup2</arg>
        <arg name="zero_linger">FALSE</arg>
        <notes/>
      </iter>
    </test>
    <test name="close_linger_lo" type="script">
        <objective>Check that tcp socket will be closed according to SO_LINGER socket option in case of loopback environment.</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="tcp_state"/>
        <arg name="sock_type"/>
        <arg name="way"/>
        <arg name="zero_linger"/>
        <arg name="sq_state"/>
        <arg name="single_sock"/>
        <arg name="set_before"/>
        <arg name="use_fork"/>
        <notes/>
      </iter>
    </test>
    <test name="rst_send_partial" type="script">
      <objective>Check that after receiving RST packet blocked send() finishes correctly</objective>
      <notes/>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="partial">FALSE</arg>
        <notes/>
      </iter>
      <iter result="PASSED">
        <arg name="env"/>
        <arg name="partial">TRUE</arg>
        <notes/>
        <results tags="zf_shim" key="ON-12876">
          <result value="FAILED">
            <verdict>send() unexpectedly failed with errno RPC-ECONNRESET</verdict>
          </result>
        </results>
      </iter>
    </test>
  </iter>
</test>
