/* SPDX-License-Identifier: Apache-2.0 */
/* (c) Copyright 2004 - 2022 Xilinx, Inc. All rights reserved. */
/* (c) Copyright 2023 OKTET Labs Ltd. */
/** @file
 * @brief Socket API Test Suite
 *
 * Common includes and definitions.
 *
 * @author Andrew Rybchenko <Andrew.Rybchenko@oktetlabs.ru>
 *
 * $Id$
 */

#ifndef __TS_SOCKAPI_TS_H__
#define __TS_SOCKAPI_TS_H__

#include "te_config.h"

#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef STDC_HEADERS
#include <stdlib.h>
#include <stdarg.h>
#endif
#if HAVE_STDLIB_H
#include <stdlib.h>
#endif
#if HAVE_UNISTD_H
#include <unistd.h>
#endif
#if HAVE_ASSERT_H
#include <assert.h>
#endif
#if HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#include "te_defs.h"
#include "te_errno.h"
#include "te_bufs.h"
#include "te_ethtool.h"
#include "logger_api.h"
#include "te_sleep.h"
#include "tapi_jmp.h"
#include "tapi_sockaddr.h"
#include "tapi_rpc.h"
#include "tapi_rpcsock_macros.h"
#include "tapi_env.h"
#include "tapi_test_log.h"
#include "tapi_rpc_socket.h"
#include "tapi_rpc_client_server.h"
#include "tapi_rpc_misc.h"
#include "tapi_cfg.h"
#include "tapi_cfg_base.h"
#include "tapi_cfg_sys.h"
#include "tapi_cfg_local.h"
#include "tapi_cfg_if.h"
#include "tapi_test.h"
#include "tapi_sh_env.h"
#include "tapi_tcp_states.h"
#include "tapi_mem.h"
#include "tapi_namespaces.h"
#include "tapi_host_ns.h"

#include "sockapi-ts_rpc.h"
#include "sockapi-ts_env.h"
#include "onload_rpc.h"
#include "sockapi-params.h"
#include "sockapi-ts_tcp.h"
#include "sockapi-ts_rpcs.h"
#include "onload.h"

/** Default ID for a new user created on TA */
#define SOCKTS_DEF_UID 21123

/** Serial logs parser agent name */
#define SERIAL_LOG_PARSER_AGENT "LogListener"

/** Serial logs parser name */
#define SERIAL_LOG_PARSER_NAME "iut"

/** Default value of @b listen() @a backlog parameter */
#define SOCKTS_BACKLOG_DEF  1

/** Default size of the buffer */
#define SOCKTS_BUF_SZ       4096

/** Special signal registrar name */
#define SIGNAL_REGISTRAR    "signal_registrar"

/** Maximum name length of leakage socket file */
#define SOCKTS_LEAK_FNAME_MAX_LEN 32

/** Control data buffer length */
#define SOCKTS_CMSG_LEN 512

/** Packets number to be sent to test a connection. */
#define SOCKTS_SEND_PACKETS_NUM 3

/**
 * Special signal registrar name (this handler also stores
 * received siginfo_t structure)
 */
#define SIGNAL_REGISTRAR_SIGINFO "signal_registrar_siginfo"

/** Zetaferno utility @b zf_stackdump name. */
#define ZF_STACKDUMP_NAME "zf_stackdump"

/**
 * Name of SF `cmdclient` utility which is used on the agent side.
 */
#define SOCKTS_CMDCLIENT "te_cmdclient"

/** Check, if errno generated by IUT */
#define IS_IUT_ERRNO(_errno) \
    (((_errno) >= RPC_EPERM) && ((_errno) <= RPC_EMEDIUMTYPE))

/** Log error, if and only if it is caused by IUT behaviour */
#define LOG_RPC_ERROR(_rpcs, _fmt...) \
    do {                                \
        int _errno = RPC_ERRNO(_rpcs);  \
                                        \
        if (IS_IUT_ERRNO(_errno))       \
        {                               \
            ERROR(_fmt);                \
        }                               \
    } while (FALSE)

/** Acceptable (absolute) inaccuracy in time measurement (in us) */
/** Inaccuracy was increased according to bug 71926. */
/** Inaccuracy was increased according to iomux/iomux_timeout test
  * behaviour on kernel 4.13.0-16-lowlatency with netns and safe_epoll3. */
#define TST_TIME_INACCURACY 150000 /* 150ms */

/** Multiplier to measure time inaccuracy in Linux-compatible way.
 *  It increases the upper bound of the time interval. */
/** Multiplier was added according to ST-1074. */
#define TST_TIME_INACCURACY_MULTIPLIER 1.25

/** IPv4 header length in bytes */
#define SOCKTS_IPV4_HDR_LEN 20

/** IPv6 header length in bytes */
#define SOCKTS_IPV6_HDR_LEN 40

/** Path to Kernel Memory Leak Detector */
#define SOCKTS_SYS_KERN_DBG_KMEMLEAK "/sys/kernel/debug/kmemleak"

/* Name of the pco server for killing Onload zombie stacks on. */
#define PCO_KILL_ZOMBIE "pco_kill_zombie"

/**
 * Check the function executing time and report if not success.
 * All time intervals are measured in microseconds.
 *
 * @param duration_                Time returned by RPC subsystem
 * @param inaccuracy_              Allowed inaccuracy in time measurement,
 *                                 should be TST_TIME_INACCURACY by default
 * @param inaccuracy_multiplier_   Inaccuracy multiplier of the upper bound
 *                                 in time measurement, should be
 *                                 TST_TIME_INACCURACY_MULTIPLIER by default
 * @param min_                     Minimum expected value
 * @param max_                     Maximum expected value
 * @param msg_                     TE macro to report error
 * @param verdict_                 TE macro to report test verdict
 * @param vtext_                   Verdict text
 */
#define CHECK_CALL_DURATION_INT_GEN(duration_, inaccuracy_,             \
                                    inaccuracy_multiplier_,             \
                                    min_, max_, msg_, verdict_, vtext_, \
                                    vfmt_...)                           \
   do {                                                                 \
       uint64_t min__ = (min_) < (inaccuracy_) ?                        \
                                    0 : (min_) - (inaccuracy_);         \
       uint64_t max__ = inaccuracy_multiplier_ * (max_)                 \
                        + (inaccuracy_);                                \
                                                                        \
       if ((uint64_t)(duration_) < min__ ||                             \
           (uint64_t)(duration_) > max__)                               \
       {                                                                \
           msg_("Unexpected RPC function executing time: "              \
                "duration %llu, expected [%llu,%llu]",                  \
                (uint64_t)(duration_), min__, max__);                   \
           if (strlen(vtext_) != 0)                                     \
               verdict_(vtext_, vfmt_);                                 \
       }                                                                \
   } while (0)

/**
 * Check the function executing time and report that test failed if
 * not success.
 * All time intervals are measured in microseconds.
 *
 * @param duration_                Time returned by RPC subsystem
 * @param inaccuracy_              Allowed inaccuracy in time measurement
 * @param inaccuracy_multiplier_   Inaccuracy multiplier of the upper bound
 *                                 in time measurement
 * @param min_                     Minimum expected value
 * @param max_                     Maximum expected value
 */
#define CHECK_CALL_DURATION_INT(duration_, inaccuracy_,             \
                                inaccuracy_multiplier_, min_, max_) \
    CHECK_CALL_DURATION_INT_GEN(duration_, inaccuracy_,             \
                                inaccuracy_multiplier_, min_, max_, \
                                TEST_FAIL, TEST_FAIL, "", "")

/**
 * Check the function executing time.
 *
 * @param duration_ - time returned by RPC subsystem
 * @param expected_ - expected time
 *
 * @se Checking quality is +/-10msec
 */
#define CHECK_CALL_DURATION(duration_, expected_) \
    CHECK_CALL_DURATION_INT((duration_), TST_TIME_INACCURACY, \
                            TST_TIME_INACCURACY_MULTIPLIER,   \
                            (expected_), (expected_))


/**
 * Get socket state and match it with specified expected value. This macro
 * reports an error with macro @p err_macro_.
 *
 * @param rpcs_         RPC server handle
 * @param sockd_        Descriptor of socket to be processed
 * @param peer_         Peer RPC server handle or NULL
 * @param peer_s_       Peer socket or -1
 * @param state_        Expected socket state
 * @param err_macro_    Macro to report the error
 * @param msg_          String message to use in the error message
 */
#define SOCKTS_CHECK_SOCK_STATE_GEN(rpcs_, sockd_, peer_, peer_s_, state_, \
                                    err_macro_, msg_)                   \
    do {                                                                \
        int rc_;                                                        \
        sockts_socket_state_t got_state;                                \
                                                                        \
        rc_ = sockts_get_socket_state((rpcs_), (sockd_),                \
                                      (peer_), (peer_s_), &got_state);  \
        if (rc_ == 0)                                                   \
            INFO("Got state: RPC (%s,%s), socket %d, %s",               \
                    (rpcs_)->ta, (rpcs_)->name, (sockd_),               \
                    socket_state2str(got_state));                       \
        if (rc_ == 0 && got_state != (state_))                          \
        {                                                               \
            err_macro_("%s, got %s; expected %s", msg_,                 \
                       socket_state2str(got_state),                     \
                       socket_state2str(state_));                       \
            rc_ = -1;                                                   \
        }                                                               \
        if (rc_ < 0)                                                    \
        {                                                               \
            MACRO_TEST_ERROR;                                           \
            MACRO_ERROR_EXIT;                                           \
        }                                                               \
    } while (0)


/**
 * Get socket state and match it with specified expected value.
 *
 * @param rpcs_     RPC server handle
 * @param sockd_    Descriptor of socket to be processed
 * @param peer_     Peer RPC server handle or @c NULL
 * @param peer_s_   Peer socket or @c -1
 * @param state_    Expected socket state
 */
#define CHECK_SOCKET_STATE(rpcs_, sockd_, peer_, peer_s_, state_) \
    SOCKTS_CHECK_SOCK_STATE_GEN(rpcs_, sockd_, peer_, peer_s_, state_, \
                                ERROR, "Wrong socket state")

/**
 * Get socket state and match it with specified expected value. The macro
 * reports an error with a verdict. Unlike macro
 * @c CHECK_SOCKET_STATE_AND_RETURN_VERDICT this one allows to use an
 * arbitrary string in the verdict message.
 *
 * @param rpcs_     RPC server handle
 * @param sockd_    Descriptor of socket to be processed
 * @param peer_     Peer RPC server handle or @c NULL
 * @param peer_s_   Peer socket or @c -1
 * @param state_    Expected socket state
 * @param msg_      String message to use in the verdict
 */
#define SOCKTS_CHECK_SOCK_STATE(rpcs_, sockd_, peer_, peer_s_, state_,  \
                                msg_)                                   \
    SOCKTS_CHECK_SOCK_STATE_GEN(rpcs_, sockd_, peer_, peer_s_, state_,  \
                                ERROR_VERDICT, msg_)

/**
 * Get socket state and match it with specified expected value.
 * This macro uses verdicts and it is the right one to be used in tests.
 *
 * @param rpcs_     RPC server handle
 * @param sockd_    Descriptor of socket to be processed
 * @param peer_     Peer RPC server handle or @c NULL
 * @param peer_s_   Peer socket or @c -1
 * @param state_    Expected socket state
 */
#define CHECK_SOCKET_STATE_AND_RETURN_VERDICT(rpcs_, sockd_, peer_,     \
                                              peer_s_, state_)      \
    SOCKTS_CHECK_SOCK_STATE(rpcs_, sockd_, peer_, peer_s_, state_,  \
                            "Wrong socket state")

/**
 * Check that received function succeeded returning expected data.
 *
 * @param _rpcs       RPC server handle.
 * @param _tx_buf     Sent data.
 * @param _rx_buf     Received data.
 * @param _exp_len    Expected data length.
 * @param _len        Length of data received (return value of the
 *                    function).
 * @param _err_msg    Prefix to print in verdicts (may be @c NULL).
 */
#define SOCKTS_CHECK_RECV_EXT(_rpcs, _tx_buf, _rx_buf, _exp_len, _len, \
                              _err_msg) \
    do {                                                                \
        const char *_msg = (_err_msg == NULL ? "" : _err_msg);          \
        const char *_delim = (_err_msg == NULL ? "" : ": ");            \
                                                                        \
        if ((long)(_len) < 0)                                           \
        {                                                               \
            TEST_VERDICT("%s%sReceive function failed on %s with "      \
                         "errno %r", _msg, _delim,                      \
                         _rpcs->name, RPC_ERRNO(_rpcs));                \
        }                                                               \
                                                                        \
        if ((ssize_t)(_len) != (ssize_t)(_exp_len))                     \
        {                                                               \
            ERROR("%d bytes is received instead of %d",                 \
                 (int)_len, (int)_exp_len);                             \
            TEST_VERDICT("%s%sIncorrect amount of data is received",    \
                         _msg, _delim);                                 \
        }                                                               \
                                                                        \
        if (memcmp(_tx_buf, _rx_buf, _len) != 0)                        \
        {                                                               \
            TEST_VERDICT("%s%sReceived data does not match sent data",  \
                         _msg, _delim);                                 \
        }                                                               \
    } while (0)

/**
 * Check that received function succeeded returning expected data.
 *
 * @param _rpcs       RPC server handle.
 * @param _tx_buf     Sent data.
 * @param _rx_buf     Received data.
 * @param _exp_len    Expected data length.
 * @param _len        Length of data received (return value of the
 *                    function).
 */
#define SOCKTS_CHECK_RECV(_rpcs, _tx_buf, _rx_buf, _exp_len, _len) \
    SOCKTS_CHECK_RECV_EXT(_rpcs, _tx_buf, _rx_buf, _exp_len, _len, NULL)

/** Call function and check rc, errno */
#define TAPI_CALL_CHECK_RC(_pco, _func, _rc, _errno, _params...) \
    do {                                                            \
        RPC_AWAIT_IUT_ERROR(_pco);                                  \
        int ret = rpc_ ## _func(_pco, _params);                     \
        if (ret != (_rc))                                           \
            TEST_VERDICT("Function '%s' returns %d, but "           \
                         "expected to return %d",                   \
                                #_func, ret, _rc);                  \
        if (ret == -1)                                              \
            CHECK_RPC_ERRNO(_pco, _errno,                           \
                            "%s() returns -1, but", #_func);        \
    } while(0)

/** Set new port in the socket address */
#define TAPI_SET_NEW_PORT(_pco, _addr) \
    do {                                                                  \
        uint16_t *_port_ptr;                                              \
        CHECK_NOT_NULL(_port_ptr = te_sockaddr_get_port_ptr(SA(_addr)));  \
        CHECK_RC(tapi_allocate_port_htons((_pco), _port_ptr));            \
    } while (0)

/** Convert hardware address to be used in tapi_arp */
#define CVT_HW_ADDR(addr_) \
    (const uint8_t *)(((struct sockaddr *)(addr_))->sa_data)

/**
 * Configure routes and other options to use a gateway host to control
 * traffic. The macro can be used with such environments like
 * @c env.peer2peer_gw and @c env.peer2peer_tst_gw .
 */
#define SOCKTS_CONFIGURE_GATEWAY \
    do {                                                                \
        rpc_socket_addr_family family;                                  \
        family =                                                        \
            sockts_domain2family(rpc_socket_domain_by_addr(iut_addr));  \
                                                                        \
        CHECK_RC(tapi_cfg_add_route_via_gw(pco_iut->ta,                 \
                 addr_family_rpc2h(family),                             \
                 te_sockaddr_get_netaddr(tst_addr),                     \
                 te_netaddr_get_size(addr_family_rpc2h(family)) * 8,    \
                 te_sockaddr_get_netaddr(gw_iut_addr)));                \
                                                                        \
        CHECK_RC(tapi_cfg_add_route_via_gw(pco_tst->ta,                 \
                 addr_family_rpc2h(family),                             \
                 te_sockaddr_get_netaddr(iut_addr),                     \
                 te_netaddr_get_size(addr_family_rpc2h(family)) * 8,    \
                 te_sockaddr_get_netaddr(gw_tst_addr)));                \
                                                                        \
        CHECK_RC(tapi_cfg_sys_set_int(pco_gw->ta, 1, NULL,              \
                                      "net/ipv4/ip_forward"));          \
                                                                        \
        CFG_WAIT_CHANGES;                                               \
    } while (0)

/**
 * Obtain domain, address family and route prefix from
 * a network address.
 *
 * @param addr_       Network address.
 * @param d_          Domain variable to set.
 * @param af_         Address family variable to set.
 * @param prefix_     Route prefix variable to set.
 */
#define GET_DOMAIN_AF_PREFIX(addr_, d_, af_, prefix_) \
    do {                                                        \
        d_ = rpc_socket_domain_by_addr(addr_);                  \
        af_ = addr_family_rpc2h(sockts_domain2family(d_));      \
        prefix_ = te_netaddr_get_size(af_) * 8;                 \
    } while (0)

/**
 * Save file descriptor in a new variable, assigning
 * the previous variable storing it to @c -1.
 *
 * @param new_var_        New variable.
 * @param old_var_        Old variable.
 */
#define SOCKTS_MOVE_FD(new_var_, old_var_) \
    do {                                   \
        new_var_ = old_var_;               \
        old_var_ = -1;                     \
    } while(0)

#ifdef __cplusplus
extern "C" {
#endif

/** Upper limit of prepared data size for stream connection */
#define SOCKTS_MSG_STREAM_MAX       1024

static inline void *
sockts_make_buf_stream(size_t *p_len)
{
    return te_make_buf(1, SOCKTS_MSG_STREAM_MAX, p_len);
}

/** Upper limit of prepared data size for datagram connection */
#define SOCKTS_MSG_DGRAM_MAX        1400

static inline void *
sockts_make_buf_dgram(size_t *p_len)
{
    return te_make_buf(1,  SOCKTS_MSG_DGRAM_MAX, p_len);
}

/**
 * Create @c rpc_iovec structure with allocated buffers.
 *
 * All parameters have special meaning for some values:
 * -1 for default, 0 for NULL in corresponding field, or positive
 * for required length.
 *
 * @param iovlen     Required number of elements in I/O vector (IN/OUT)
 * @param buflen     Required total length of allocated buffer space
 *                   (IN/OUT)
 * @param empty_bufs Number of zero-length bufs (if it is negative, it is
 *                   ignored, otherwise exactly empty_bufs elements will
 *                   have zero length (IN).
 *
 * @return Pointer to array of rpc_iovec structures.
 */
extern struct rpc_iovec *sockts_make_iovec_gen(int *iovlen,
                                               ssize_t *buflen,
                                               int empty_bufs);

/**
 * Create @c rpc_iovec structure with allocated buffers.
 *
 * All parameters have special meaning for some values:
 * -1 for default, 0 for NULL in corresponding field, or positive
 * for required length.
 *
 * @param iovlen    Required number of elements in I/O vector (IN/OUT)
 * @param buflen    Required total length of allocated buffer space (IN/OUT)
 *
 * @return Pointer to array of rpc_iovec structures.
 */
extern struct rpc_iovec *sockts_make_iovec(int *iovlen, ssize_t *buflen);

/**
 * Create an array of @p rpc_iovec structures (simple IO vectors of
 * equal size and equal visible and real lengths).
 *
 * @param iovecs    Where pointer to array should be placed
 * @param buf_len   Lenght of each IO vector
 * @param iov_len   Number of IO vectors
 *
 * @return Status code
 */
extern te_errno create_plain_iovecs(rpc_iovec **iovecs, int buf_len,
                                    int iov_len);

/**
 * Copy data from IO vectors to buffer in order.
 *
 * @param iovecs    IO vectors
 * @param iov_len   Number of IO vectors
 * @param buf       Buffer
 * @param buf_len   Length of buffer
 *
 * @return Length of data written
 */
extern int iovecs_to_buf(rpc_iovec *iovecs, int iov_len,
                         char *buf, int buf_len);

/**
 * Free @c rpc_iovec structure.
 *
 * @param iovec     Array to be freed
 * @param iovcnt    Number of elements in array
 */
extern void sockts_free_iovecs(struct rpc_iovec *iovec, size_t iovcnt);

/**
 * Create @c rpc_msghdr structure with allocated buffers.
 *
 * All parameters have special meaning for some values:
 * -1 for default, 0 for NULL in corresponding field, or positive
 * for required length.
 *
 * @param namelen   Required length of the @a msg_name field
 * @param iovlen    Required number of elements in I/O vector
 * @param buflen    Required total length of allocated buffer space (IN/OUT)
 * @param ctrllen   Required length of the @a msg_control field
 *
 * @return Status code.
 */
extern struct rpc_msghdr *sockts_make_msghdr(int namelen, int iovlen,
                                             ssize_t *buflen, int ctrllen);

/**
 * Free @c rpc_msghdr structure.
 *
 * @param msg       Structure to be freed
 */
extern void sockts_free_msghdr(struct rpc_msghdr *msg);


/**
 * Create Tx and Rx vectors of buffers.
 *
 * @param tx_vector    - location of the tx vector
 * @param rx_vector    - location of the rx vector
 * @param rrx_vector   - location of the rrx vector
 * @param vector_len   - the length of rx/tx vector
 */
static inline void
sockts_make_vector(struct rpc_iovec *tx_vector, struct rpc_iovec *rx_vector, 
                   struct rpc_iovec *rrx_vector, int vector_len)
{
    int i;

    for (i = 0; i < vector_len; i++)
    {
        tx_vector[i].iov_base = te_make_buf(10, 40, &(tx_vector[i].iov_len));
        tx_vector[i].iov_rlen = tx_vector[i].iov_len;
        rx_vector[i].iov_base = te_make_buf_min(tx_vector[i].iov_len, 
                                                  &(rx_vector[i].iov_len));
        rx_vector[i].iov_rlen = rx_vector[i].iov_len;
        rrx_vector[i].iov_base = te_make_buf_min(rx_vector[i].iov_len,
                                                   &(rrx_vector[i].iov_len));
        rrx_vector[i].iov_rlen = rrx_vector[i].iov_len;
    }
}

/**
 * Create and fill in the both Tx and Rx msghdrs.
 *
 * @param tx_msghdr    - location of the tx msghdr
 * @param rx_msghdr    - location of the rx msghdr
 * @param rrx_msghdr   - location of the rrx msghdr
 * @param tx_name      - destination address
 * @param vector_len   - the length of rx/tx vector
 */
static inline void
sockts_make_txrx_msghdr(rpc_msghdr *tx_msghdr, rpc_msghdr *rx_msghdr,
                        rpc_msghdr *rrx_msghdr, const void *tx_name, 
                        size_t vector_len)
{
    size_t  tx_name_len = te_sockaddr_get_size(tx_name);

    memset(tx_msghdr, 0, sizeof(*tx_msghdr));
    memset(rx_msghdr, 0, sizeof(*rx_msghdr));
    memset(rrx_msghdr, 0, sizeof(*rrx_msghdr));

    tx_msghdr->msg_iovlen = rx_msghdr->msg_iovlen = rrx_msghdr->msg_iovlen =
    tx_msghdr->msg_riovlen = rx_msghdr->msg_riovlen = rrx_msghdr->msg_riovlen =
                                                                     vector_len;
    tx_msghdr->msg_iov = calloc(vector_len, sizeof(struct rpc_iovec));
    rx_msghdr->msg_iov = calloc(vector_len, sizeof(struct rpc_iovec));
    rrx_msghdr->msg_iov = calloc(vector_len, sizeof(struct rpc_iovec));

    sockts_make_vector(tx_msghdr->msg_iov, rx_msghdr->msg_iov, 
                       rrx_msghdr->msg_iov, vector_len);

    /* Prepare location and copy remote address */
    tx_msghdr->msg_name = malloc(tx_name_len);
    memcpy(tx_msghdr->msg_name, tx_name, tx_name_len);

    rx_msghdr->msg_name = calloc(1, tx_name_len);
    rrx_msghdr->msg_name = calloc(1, tx_name_len);

    tx_msghdr->msg_namelen = rx_msghdr->msg_namelen = rrx_msghdr->msg_namelen =
       tx_msghdr->msg_rnamelen = rx_msghdr->msg_rnamelen = 
          rrx_msghdr->msg_rnamelen = tx_name_len;
}

/**
 * Free allocated resources involved in msghdr creation.
 *
 * @param tx_msghdr    - location of the tx msghdr
 * @param rx_msghdr    - location of the rx msghdr
 * @param rrx_msghdr   - location of the rrx msghdr
 */
static inline void
sockts_clear_txrx_msghdr(rpc_msghdr *tx_msghdr,
                         rpc_msghdr *rx_msghdr,
                         rpc_msghdr *rrx_msghdr)
{
    size_t i;

    free(tx_msghdr->msg_name);
    free(rx_msghdr->msg_name);
    free(rrx_msghdr->msg_name);
    free(tx_msghdr->msg_control);
    free(rx_msghdr->msg_control);
    free(rrx_msghdr->msg_control);
    for (i = 0; i < tx_msghdr->msg_iovlen; i++)
    {
         free(tx_msghdr->msg_iov[i].iov_base);
         free(rx_msghdr->msg_iov[i].iov_base);
         free(rrx_msghdr->msg_iov[i].iov_base);
    }
    free(tx_msghdr->msg_iov);
    free(rx_msghdr->msg_iov);
    free(rrx_msghdr->msg_iov);
}

/** Iovec and buffer comparison results */
typedef enum {
    SOCKTS_BUF_EQUAL_IOVEC       =  0, /**< Data in iovecs and data
                                            in buffer are equal */
    SOCKTS_BUF_INCLUDED_IN_IOVEC =  1, /**< Data in buffer is begin
                                            of data in iovec */
    SOCKTS_BUF_INCLUDES_IOVEC    =  2, /**< Data in iovec is begin of
                                            data in buffer */
    SOCKTS_BUF_DONT_MATCH_IOVEC  =  3  /**< Data in buffer and data
                                            in iovec don't match */
} sockts_iovec_buf_cmp_result;

/**
 * Compare data in buffer of iovec and data in buffer of bytes
 *
 * @param iov       pointer to buffer with iovec structs
 * @param iov_num   number of iovec structs
 * @paarm buf       buffer with data to compare
 * @param buf_len   length of bufer with data
 *
 * @return  Comparison result. Values from @ref sockts_iovec_buf_cmp_result
 */
extern sockts_iovec_buf_cmp_result
sockts_compare_iovec_and_buffer(struct rpc_iovec *iov,
                                size_t iov_num,
                                char *buf,
                                size_t buf_len);

/**
 * Check whether buffer matches initial part of data stored in iovecs
 *
 * @param iov       pointer to buffer with iovec structs
 * @param iov_num   number of iovec structs
 * @paarm buf       buffer with data to compare
 * @param buf_len   length of bufer with data
 *
 * @return  @c TRUE in case of match, @c FALSE otherwise
 */
extern te_bool
sockts_iovec_buf_cmp_start(struct rpc_iovec *iov,
                           size_t iov_num,
                           char *buf,
                           size_t buf_len);

/**
 * Compare tx and rx msghdr info.
 *
 * @param tx_msghdr    - location of the tx msghdr
 * @param rx_msghdr    - location of the rx msghdr
 * @param addr         - address for comparison
 * @param tx_len       - length of sent data
 * @param rx_len       - length of received data
 *
 * @retval  0   - success
 * @retval -1   - data is not validated
 */
extern int sockts_compare_txrx_msgdata(rpc_msghdr *tx_msghdr,
                                       rpc_msghdr *rx_msghdr,
                                       const struct sockaddr *addr,
                                       size_t tx_len, size_t rx_len);


/**
 * Compare local address of a socket and remote address of its pair.
 *
 * @param local   - RPC server handle
 * @param sock    - socket on local  RPC server
 * @param remote  - RPC server handle
 * @param peer    - socket on remote RPC server
 * 
 * @retval  0   - success
 * @retval -1   - address is not validated
 */
extern int sockts_compare_sock_peer_name(rcf_rpc_server *local, int sock,
                                         rcf_rpc_server *remote, int peer);
/**
 * Check validity of information in pointed structure according to
 * address family and passed length.
 *
 * @param _addr     - Pointer to data
 * @param _addr_len - The length of checked data
 */

#define CHECK_NAME(_addr, _addr_len) \
    do {                                                                    \
        struct sockaddr *addr = SA(_addr);                                  \
        if (addr == NULL)                                                   \
           TEST_FAIL("Not valid pointer to data is passed");                \
        switch (addr->sa_family)                                            \
        {                                                                   \
            char addr_str[INET6_ADDRSTRLEN];                                \
            case AF_INET:                                                   \
                if (_addr_len < sizeof(struct sockaddr_in) ||               \
                    _addr_len > (sizeof(struct sockaddr_in)))               \
                {                                                           \
                    TEST_FAIL("addr_len=%d returned for AF_INET address "   \
                              "is mistaken", _addr_len);                    \
                }                                                           \
                if (inet_ntop(AF_INET, &(SIN(addr)->sin_addr),              \
                              addr_str, sizeof(addr_str)) == NULL)          \
                    TEST_FAIL("network address can not be converted "       \
                              "to char string");                            \
                else                                                        \
                    INFO("CHECK_NAME(): converted address is %s:%d",        \
                         addr_str, ntohs(SIN(addr)->sin_port));             \
                break;                                                      \
            case AF_INET6:                                                  \
                if (_addr_len < sizeof(struct sockaddr_in6) ||              \
                    _addr_len > (sizeof(struct sockaddr_in6)))              \
                {                                                           \
                    TEST_FAIL("addr_len=%d returned for AF_INET6 address "  \
                              "is mistaken", _addr_len);                    \
                }                                                           \
                if (inet_ntop(AF_INET6, &(SIN6(addr)->sin6_addr),           \
                              addr_str, sizeof(addr_str)) == NULL)          \
                    TEST_FAIL("network address can not be converted "       \
                              "to char string");                            \
                else                                                        \
                    INFO("CHECK_NAME(): converted address is %s:%d",        \
                         addr_str, ntohs(SIN6(addr)->sin6_port));           \
                break;                                                      \
            default:                                                        \
                ERROR("CHECK_NAME(): Address family %d is not supported, "  \
                      "operation has no effect", addr->sa_family);          \
        }                                                                   \
    } while (0)

/** Socket states */
typedef enum {
    STATE_CLEAR = 0,            /**< Socket is just created but not bound */
    STATE_BOUND,                /**< Socket is bound but not connected or
                                     listen */
    STATE_LISTENING,            /**< Socket is listening for TCP 
                                     connections */
    STATE_CONNECTED,            /**< Socket is connected and data passes
                                     in both directions */
    STATE_SHUT_RD,              /**< Connected socket, shutdown for reading */
    STATE_SHUT_WR,              /**< Connected socket, shutdown for writing */
    STATE_SHUT_RDWR,            /**< Connected socket, shutdown for 
                                     read/write */
    STATE_CLOSED,               /**< Passed socket descriptor does not 
                                     correpond to any open socket or
                                     file. */
} sockts_socket_state_t;

/**
 * Convert enum sockts_socket_state_t to string.
 *
 * @param state    - value of enum sockts_socket_state_t to be converted
 *
 * @return pointer to null-terminated string.
 */
const char *socket_state2str(sockts_socket_state_t state);

/**
 * Obtain current socket state
 *
 * @param pco       RPC server handle
 * @param sock      Descriptor of socket to be processed
 * @param peer      Peer RPC server handle or NULL
 * @param peer_s    Peer socket or -1
 * @param state     Obtained current sock socket state (OUT)
 *
 * @pre 
 * - Receive buffer of socket is assumed to be empty, 
 *   otherwise socket will be detected 
 *   as shutdown for reading. 
 * - If socket is stream and connected, its send buffer is assumed to be 
 *   empty, otherwise, if it is full, socket will be detected as shutdown for
 *   writing. 
 *
 * @retval  0   - success
 * @retval -1   - error
 */
extern int sockts_get_socket_state(rcf_rpc_server *pco, int sock,
                                   rcf_rpc_server *peer, int peer_s,
                                   sockts_socket_state_t *state);

/**
 * Convert 'rpc_socket_domain' type to 'rpc_socket_addr_family', in case 
 * some domain supports many address families the mapping is done to
 * an arbitrary family. 
 *
 * @param domain  Domain to be converted in address family
 *
 * @return Converted value
 *
 * @note For PF_INET and PF_INET6 you can be sure that the mapping 
 * is done in a way AF_INET and AF_INET6 accordingly.
 */
extern rpc_socket_addr_family sockts_domain2family(rpc_socket_domain domain);

/**
 * Returns the length of sockaddr structure that corresponds to specified
 * domain
 *
 * @param domain  Domain value
 *
 * @return size of sockaddr structure for domain, or zero if domain is
 * unknown
 */
extern int sockaddr_get_size_by_domain(rpc_socket_domain domain);

/**
 * Returns the length of raw address structure corresponding to specified
 * domain
 *
 * @param domain  Domain value
 *
 * @return        Size of address for domain, or zero for unknown domain
 */
extern int
inaddr_get_size_by_domain(rpc_socket_domain domain);

/**
 * Return IP header length corresponding to specified address.
 *
 * @param addr    An address
 *
 * @return IP header length in bytes
 */
static inline int
sockts_ip_hdr_len_by_addr(const struct sockaddr *addr)
{
    return rpc_socket_domain_by_addr(addr) == RPC_PF_INET6 ?
              SOCKTS_IPV6_HDR_LEN : SOCKTS_IPV4_HDR_LEN;
}

/**
 * Find a specific control message in control data retrieved by
 * @b recvmsg().
 *
 * @param msghdr      Pointer to @b rpc_msghdr structure.
 * @param level       Protocol level.
 * @param type        Option type.
 * @param other_cmsg  If not @c NULL, will be set to @c TRUE if
 *                    other control messages were encountered,
 *                    or if the requested control message was
 *                    encountered more than once.
 *
 * @return Pointer to found control message or @c NULL.
 */
static inline struct cmsghdr *
sockts_msg_lookup_control_data_ext(rpc_msghdr *msghdr, int level, int type,
                                   te_bool *other_cmsg)
{
    struct msghdr   msg;
    struct cmsghdr *cmsg = NULL;
    struct cmsghdr *result = NULL;

    if (other_cmsg != NULL)
        *other_cmsg = FALSE;

    if (msghdr->msg_controllen == 0)
        return NULL;

    /* Bug 56027: don't use type cast rpc_msghdr -> 'struct msghdr'! */
    memset(&msg, 0, sizeof(msg));
    msg.msg_control = msghdr->msg_control;
    msg.msg_controllen = msghdr->msg_controllen;

    for (cmsg = CMSG_FIRSTHDR(&msg);
         cmsg != NULL;
         cmsg = CMSG_NXTHDR(&msg, cmsg))
    {
        RING("Control message: level %d, type %d: %s",
             cmsg->cmsg_level, cmsg->cmsg_type,
             sockopt_rpc2str(cmsg_type_h2rpc(cmsg->cmsg_level,
                                             cmsg->cmsg_type)));

        if (cmsg->cmsg_level == level && cmsg->cmsg_type == type &&
            result == NULL)
        {
            result = cmsg;
        }
        else
        {
            if (other_cmsg != NULL)
                *other_cmsg = TRUE;
        }
    }

    return result;
}

/**
 * Lookup for control data passed in ancillary data part of the msghdr.
 *
 * @param msghdr    Pointer on msghdr returned recvmsg()
 * @param level     Protocol level
 * @param type      Option type
 *
 * @return Pointer to found control message or @c NULL.
 *
 * @se Data should be retrieved by means of @b CMSG_DATA macro.
 */
static inline struct cmsghdr *
sockts_msg_lookup_control_data(rpc_msghdr *msghdr, int level, int type)
{
    return sockts_msg_lookup_control_data_ext(msghdr, level, type, NULL);
}

/**
 * Fill tarpc_mreqn structure before setsockopt() call
 * socket options IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP, IP_MULTICAST_IF
 *
 * @param  __mreq     tarpc_mreqn structure to fill
 * @param  __multaddr multicast address
 * @param __ifaddr    local unicast address
 * @param __ifindex   local interface index
 */
#define FILL_TARPC_MREQN(__mreq, __multaddr, __ifaddr, __ifindex) \
    do {                                                            \
        memset(&__mreq, 0, sizeof(__mreq));                         \
        __mreq.type = OPT_MREQN;                                    \
        memcpy(&__mreq.multiaddr,                                   \
               te_sockaddr_get_netaddr(__multaddr),                 \
               sizeof(struct in_addr));                             \
        memcpy(&__mreq.address, te_sockaddr_get_netaddr(__ifaddr),  \
               sizeof(struct in_addr));                             \
        __mreq.ifindex = __ifindex;                                 \
    } while (0)

/**
 * Join the multicast group on specified socket. Jump on error if
 * RPC_AWAIT_IUT_ERROR is not set.
 *
 * @param rpcs            RPC server handle
 * @param sockd           Socket descriptor
 * @param mcast_addr      Address of the multicast group the the socket joins
 * @param if_index        Interface index of the interface that should join
 *                        the multiaddr group
 *
 * @return Status of the operation.
 *
 * @retval  0  on success
 * @retval -1  on failure
 */
extern int mcast_join(rcf_rpc_server *rpcs, int sockd, 
                      const struct sockaddr *mcast_addr,
                      int if_index);

/**
 * Leave the multicast group on specified socket. Jump on error if
 * RPC_AWAIT_IUT_ERROR is not set.
 *
 * @param rpcs            RPC server handle
 * @param sockd           Socket descriptor
 * @param mcast_addr      Address of the multicast group the the socket leaves
 * @param if_index        Interface index of the interface that should leave
 *                        the multiaddr group
 *
 * @return Status of the operation.
 *
 * @retval  0  on success
 * @retval -1  on failure
 */
extern int mcast_leave(rcf_rpc_server *rpcs, int sockd, 
                       const struct sockaddr *mcast_addr,
                       int if_index);

/**
 * Obtain the number of bytes that is sufficient for keeping information 
 * about all the interfaces in the system.
 *
 * @param rpcs   RPC server handle
 * @param sockd  Socket descriptor
 * @param size   Number of bytes (OUT)
 *
 * @return Status of the operation
 * @retval  0  on success
 * @retval -1  on failure
 */
extern int get_ifconf_size(rcf_rpc_server *rpcs, int sockd, int *size);

/**
 * Whether the specified address from a particulat domain is in use or not
 *
 * @param rpcs      RPC server handle
 * @param domain    Address domain
 * @param sock_type Type of socket to be used for the checking
 * @param addr      Address to be checked if it is in use
 *
 * @return Status of the checking
 * 
 * @retval TRUE   the address is in use
 * @retval FALSE  the address is not in use
 * @retval -1     an error has been occurred
 */
extern int is_addr_inuse(rcf_rpc_server *rpcs, rpc_socket_domain domain,
                         rpc_socket_type sock_type,
                         const struct sockaddr *addr);

/**
 * Establish TCP connection.
 *
 * @param rpcs_clnt       RPC server from which @b connect() is called.
 * @param s_conn          Socket on which @b connect() is called.
 * @param rpcs_srv        RPC server with listener socket.
 * @param s_listener      Listener socket.
 * @param src_addr        Expected source address of connection request
 *                        (if @c NULL, not checked).
 * @param conn_addr       Address to which to connect.
 * @param srv_domain      Socket domain of the listener socket (used only
 *                        for source address check, ignored if @p src_addr
 *                        is not specified).
 * @param vpref           String to print in the beginning of verdicts.
 *
 * @return Socket returned by @b accept() or negative value in case of
 *         error.
 */
extern int sockts_tcp_connect(rcf_rpc_server *rpcs_clnt, int s_conn,
                              rcf_rpc_server *rpcs_srv, int s_listener,
                              const struct sockaddr *src_addr,
                              const struct sockaddr *conn_addr,
                              rpc_socket_domain srv_domain,
                              const char *vpref);

/**
 * Check data transmission in one direction.
 *
 * @param rpcs1             RPC server holding the socket which sends data.
 * @param s1                Socket from which to send data.
 * @param rpcs2             RPC server holding the socket which receives
 *                          data.
 * @param s2                Socket which should receive data.
 * @param s1_addr           Expected source address of received data
 *                          (if @c NULL, not checked).
 * @param s2_addr           Address to which to send data. If specified,
 *                          @b sendto() is used, otherwise @b send() is
 *                          used.
 * @param s2_domain         Socket domain of @p s2 (used only for source
 *                          address check, ignored if @p s1_addr is not
 *                          specified).
 * @param check_dgram       Check that the same datagrams are received
 *                          in the same order by the other end.
 * @param vpref             String with which to start verdicts (may be
 *                          empty).
 *
 * @return Status code.
 */
extern te_errno sockts_test_send(rcf_rpc_server *rpcs1, int s1,
                                 rcf_rpc_server *rpcs2, int s2,
                                 const struct sockaddr *s1_addr,
                                 const struct sockaddr *s2_addr,
                                 rpc_socket_domain s2_domain,
                                 te_bool check_dgram_size,
                                 const char *vpref);

/** Possible return values of sockts_test_send_ext() */
typedef enum {
    SOCKTS_TEST_SEND_SUCCESS,                 /**< Success */
    SOCKTS_TEST_SEND_FIRST_SEND_FAIL,         /**< The first sending
                                                   failed */
    SOCKTS_TEST_SEND_NON_FIRST_SEND_FAIL,     /**< Not the first sending
                                                   failed */
    SOCKTS_TEST_SEND_UNEXP_SEND_RC,           /**< Sending function returned
                                                   unexpected positive
                                                   value */
    SOCKTS_TEST_SEND_ZERO_SEND_RC,            /**< Sending function returned
                                                   zero */
    SOCKTS_TEST_SEND_NO_DATA,                 /**< Peer did not become
                                                   readable */
    SOCKTS_TEST_SEND_RECV_FAIL,               /**< Receiving function
                                                   failed */
    SOCKTS_TEST_SEND_ZERO_RECV_RC,            /**< Receiving function
                                                   returned zero */
    SOCKTS_TEST_SEND_RECV_UNEXP_ADDR,         /**< recvfrom() returned
                                                   unexpected address */
    SOCKTS_TEST_SEND_UNEXP_DGRAM,             /**< Unexpected datagram
                                                   was received */
    SOCKTS_TEST_SEND_LOST_DGRAM,              /**< Some datagrams were
                                                   lost */
    SOCKTS_TEST_SEND_REORDERED_DGRAMS,        /**< Datagrams were received
                                                   in a wrong order */
    SOCKTS_TEST_SEND_UNEXP_RECV_DATA_LEN,     /**< Unexpected number of
                                                   bytes was received */
    SOCKTS_TEST_SEND_UNEXP_RECV_DATA,         /**< Received data did not
                                                   match sent data */
    SOCKTS_TEST_SEND_OUT_OF_MEMORY,           /**< Failed to allocate
                                                   memory */
} sockts_test_send_rc;

/**
 * Get string description of @ref sockts_test_send_rc value.
 *
 * @param rc        Value.
 *
 * @return String description.
 */
extern const char *sockts_test_send_rc2str(sockts_test_send_rc rc);

/** Arguments for sockts_test_send_ext() */
typedef struct sockts_test_send_ext_args {
    rcf_rpc_server          *rpcs_send;       /**< RPC server used for
                                                   sending */
    rcf_rpc_server          *rpcs_recv;       /**< RPC server used for
                                                   receiving */
    int                      s_send;          /**< Socket used for
                                                   sending */
    int                      s_recv;          /**< Socket used for
                                                   receiving */
    rpc_socket_domain        s_recv_domain;   /**< Domain of the
                                                   receiving socket
                                                   (used only when
                                                   checking source
                                                   address) */
    const struct sockaddr   *src_addr;        /**< Source address
                                                   (if @c NULL, ignored,
                                                   otherwise it is checked
                                                   that recvfrom() returns
                                                   this address) */
    const struct sockaddr   *dst_addr;        /**< Destination address.
                                                   If not @c NULL, sendto()
                                                   is called with this
                                                   address. Otherwise
                                                   send() is called. */
    te_bool                  check_dgram;     /**< If @c TRUE, check
                                                   that receiver
                                                   receives exactly the
                                                   same datagrams and
                                                   in the same order
                                                   as sender sends */
    int                      send_wait;       /**< If positive, wait
                                                   this number of
                                                   milliseconds before
                                                   the next send */
    int                      recv_timeout;    /**< How long to wait
                                                   for data on receiver,
                                                   in milliseconds */
    unsigned int             pkts_num;        /**< Number of packets to
                                                   send */
    te_bool                  print_verdicts;  /**< If @c TRUE, print
                                                   verdicts about errors */
    const char              *vpref;           /**< Message with which to
                                                   start a verdict
                                                   (may be @c NULL) */
} sockts_test_send_ext_args;

/** Initializer for sockts_test_send_ext_args */
#define SOCKTS_TEST_SEND_EXT_ARGS_INIT \
    { .rpcs_send = NULL,                        \
      .rpcs_recv = NULL,                        \
      .s_send = -1,                             \
      .s_recv = -1,                             \
      .s_recv_domain = RPC_PF_UNKNOWN,          \
      .src_addr = NULL,                         \
      .dst_addr = NULL,                         \
      .check_dgram = FALSE,                     \
      .send_wait = 0,                           \
      .recv_timeout = TAPI_WAIT_NETWORK_DELAY,  \
      .pkts_num = SOCKTS_SEND_PACKETS_NUM,      \
      .print_verdicts = TRUE,                   \
      .vpref = NULL }

/**
 * Extended version of sockts_test_send().
 *
 * @param args        Pointer to structure with arguments.
 *
 * @return Value from @ref sockts_test_send_rc
 */
extern sockts_test_send_rc sockts_test_send_ext(
                                sockts_test_send_ext_args *args);

/**
 * Macro for checking @ref sockts_test_send_rc value.
 * If it is not @c SOCKTS_TEST_SEND_SUCCESS, it logs error
 * and jumps to cleanup.
 *
 * @param _expr         Expression evaluating to @ref sockts_test_send_rc
 *                      value
 */
#define CHECK_SOCKTS_TEST_SEND_RC(_expr) \
    do {                                                                \
        sockts_test_send_rc _rc = (_expr);                              \
                                                                        \
        if (_rc != 0)                                                   \
        {                                                               \
            TEST_FAIL("File %s line %d: %s evaluates to %d ('%s')",     \
                      __FILE__, __LINE__,                               \
                      #_expr, _rc, sockts_test_send_rc2str(_rc));       \
        }                                                               \
    } while (0)

/**
 * Check that socket can receive data from peer (in case of UDP)
 * or can accept connection from peer (in case of TCP).
 *
 * @param rpcs1       RPC server from which data (connection request)
 *                    is sent.
 * @param s1          Socket from which data or connection request is sent.
 * @param rpcs2       RPC server which receives data (connection request).
 * @param s2          Socket wich receives data (connection request).
 * @param s1_addr     Expected source address (if @c NULL, not checked).
 * @param s2_addr     Address to which to send data (connection request).
 * @param s2_domain   Socket domain of @p s2 (used only for source address
 *                    check, ignored if @p s1_addr is not specified).
 * @param sock_type   Socket type.
 * @param s_acc       Where accepted socket should be saved.
 * @param vpref       String with which to start verdicts.
 *
 * @return Status code.
 */
extern te_errno sockts_check_recv_accept(rcf_rpc_server *rpcs1, int s1,
                                         rcf_rpc_server *rpcs2, int s2,
                                         const struct sockaddr *s1_addr,
                                         const struct sockaddr *s2_addr,
                                         rpc_socket_domain s2_domain,
                                         rpc_socket_type sock_type,
                                         int *s_acc,
                                         const char *vpref);

/**
 * Check that traffic may be sent/received via connection in both
 * directions.
 *
 * @param rpcs1         RPC server holding the first connection endpoint
 * @param s1            socket corresponding to the first endpoint
 * @param rpcs2         RPC server holding the second connection endpoint
 * @param s2            socket corresponding to the first endpoint
 */
extern void sockts_test_connection(rcf_rpc_server *rpcs1, int s1,
                                   rcf_rpc_server *rpcs2, int s2);

/**
 * Check that traffic may be sent/received via connection in both
 * directions.
 *
 * @param rpcs1         RPC server holding the first connection endpoint.
 * @param s1            Socket corresponding to the first endpoint.
 * @param rpcs2         RPC server holding the second connection endpoint.
 * @param s2            Socket corresponding to the second endpoint.
 * @param s2_addr       Address to which the second socket is bound.
 * @param sock_type     Type of the first socket.
 */
extern void sockts_test_connection_ext(rcf_rpc_server *rpcs1, int s1,
                                       rcf_rpc_server *rpcs2, int s2,
                                       const struct sockaddr *s2_addr,
                                       sockts_socket_type sock_type);

/**
 * Check datagram transmission from @p s1 to @p s2 using @c sendto().
 *
 * @param rpcs1         First RPC server handle
 * @param s1            Socket to send a datagram
 * @param rpcs2         Second RPC server handle
 * @param s2            Socket to receive the datagram
 * @param dst_addr      Destination address
 */
extern void sockts_test_udp_sendto(rcf_rpc_server *rpcs1, int s1,
                                   rcf_rpc_server *rpcs2, int s2,
                                   const struct sockaddr *dst_addr);

/**
 * Check datagram transmission in both directions between @p s1 and @p s2
 * using @c sendto().
 *
 * @param rpcs1         First RPC server handle
 * @param s1            First socket
 * @param addr1         First peer address
 * @param rpcs2         Second RPC server handle
 * @param s2            Second socket
 * @param addr2         Second peer address
 */
extern void sockts_test_udp_sendto_bidir(rcf_rpc_server *rpcs1, int s1,
                                         const struct sockaddr *addr1,
                                         rcf_rpc_server *rpcs2, int s2,
                                         const struct sockaddr *addr2);

/**
 * Bind the socket to device with specified name.
 *
 * @param   rpcs       RPC server
 * @param   s          Socket descriptor
 * @param   if_name    Interface name
 *
 * @return  0          if binding succeeded;
 *          -1         if any error occured; errno is set appropriately.
 */
static inline int
rpc_bind_to_device(rcf_rpc_server *rpcs, int s, const char *if_name)
{
    int     ret;
    te_bool err_jump = rpcs->iut_err_jump;
    char   *if_nambuf = (char *)malloc(IFNAMSIZ);

    rpcs->iut_err_jump = err_jump;

    if (if_nambuf == NULL)
    {
        errno = RPC_ENOMEM;
        return -1;
    }
    else
    {
        memcpy(if_nambuf, if_name, strlen(if_name) + 1);
        RPC_AWAIT_IUT_ERROR(rpcs);
        ret = rpc_setsockopt_raw(rpcs, s, RPC_SO_BINDTODEVICE,
                                 if_nambuf, IFNAMSIZ);
        if (ret != 0)
        {
            TEST_VERDICT("setsockopt(SOL_SOCKET, SO_BINDTODEVICE) "
                         "failed with errno %s",
                         errno_rpc2str(RPC_ERRNO(rpcs)));
        }
        return ret;
    }
}

/** 
 * Generic prototype for RPC receive functions 
 *
 * @param rpcs          RPC server handle
 * @param s             file descriptor
 * @param buf           receive buffer
 * @param buflen        receive buffer length
 * @param flags         receive flags (RPC_MSG_*)
 *
 * @return -1 (failure) or number of received bytes
 */
typedef ssize_t (*rpc_recv_f)(rcf_rpc_server *rpcs, int s,
                              void *buf, size_t buflen, 
                              rpc_send_recv_flags flags);

/** Wrapper for recvfrom(), see rpc_recv_f type definition */
static inline ssize_t 
rpc_recv_func_recvfrom(rcf_rpc_server *rpcs, int s,
                       void *buf, size_t buflen, 
                       rpc_send_recv_flags flags)
{
    return rpc_recvfrom(rpcs, s, buf, buflen, flags, NULL, NULL);
}                   

/** Wrapper for recvmsg(), see rpc_recv_f type definition */
static inline ssize_t 
rpc_recv_func_recvmsg(rcf_rpc_server *rpcs, int s,
                      void *buf, size_t buflen, 
                      rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buflen };
    rpc_msghdr       msg;

    if (buf == NULL)
        vector.iov_rlen = 0;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_recvmsg(rpcs, s, &msg, flags);
}

/** Wrapper for onload_zc_recv(), see rpc_recv_f type definition */
static inline ssize_t
rpc_recv_func_onload_zc_recv(rcf_rpc_server *rpcs, int s,
                             void *buf, size_t buflen,
                             rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buflen };
    rpc_msghdr       msg;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_simple_zc_recv(rpcs, s, &msg, flags);
}

/** Wrapper for onload_zc_hlrx_recv_zc(), see rpc_recv_f type definition */
static inline ssize_t
rpc_recv_func_hlrx_recv_zc(rcf_rpc_server *rpcs, int s,
                           void *buf, size_t buflen,
                           rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buflen };
    rpc_msghdr       msg;

    if (buf == NULL)
        vector.iov_rlen = 0;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_simple_hlrx_recv_zc(rpcs, s, &msg, flags, TRUE);
}

/** Wrapper for onload_zc_hlrx_recv_copy(), see rpc_recv_f type definition */
static inline ssize_t
rpc_recv_func_hlrx_recv_copy(rcf_rpc_server *rpcs, int s,
                             void *buf, size_t buflen,
                             rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buflen };
    rpc_msghdr       msg;

    if (buf == NULL)
        vector.iov_rlen = 0;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_simple_hlrx_recv_copy(rpcs, s, &msg, flags, TRUE);
}

/** Wrapper for recvmmsg(), see rpc_recv_f type definition */
static inline ssize_t 
rpc_recv_func_recvmmsg(rcf_rpc_server *rpcs, int s,
                       void *buf, size_t buflen, 
                       rpc_send_recv_flags flags)
{
    struct rpc_mmsghdr mmsghdr;
    struct rpc_iovec   vector = { buf, buflen, buflen };
    rpc_msghdr        *msg = &mmsghdr.msg_hdr;

    int rc;

    if (buf == NULL)
        vector.iov_rlen = 0;

    memset(msg, 0, sizeof(*msg));
    msg->msg_iov = &vector;
    msg->msg_iovlen = msg->msg_riovlen = 1;

    if ((rc = rpc_recvmmsg_alt(rpcs, s, &mmsghdr, 1, flags, NULL)) == -1)
        return -1;

    return mmsghdr.msg_len;
}

/** Wrapper for read(), see rpc_recv_f type definition */
static inline ssize_t 
rpc_recv_func_read(rcf_rpc_server *rpcs, int s,
                   void *buf, size_t buflen, 
                   rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for read()");

    return rpc_read(rpcs, s, buf, buflen);
}

/** Wrapper for libc read(), see rpc_recv_f type definition */
static inline ssize_t
rpc_recv_func_sys_read(rcf_rpc_server *rpcs, int s,
                       void *buf, size_t buflen,
                       rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for read()");

    rpcs->use_libc_once = TRUE;
    return rpc_read(rpcs, s, buf, buflen);
}

/** Wrapper for readv(), see rpc_recv_f type definition */
static inline ssize_t 
rpc_recv_func_readv(rcf_rpc_server *rpcs, int s,
                    void *buf, size_t buflen, 
                    rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buf == NULL ? 0 : buflen };

    if (flags != 0)
        ERROR("Non-zero receive flags are specified for readv()");
        
    return rpc_readv(rpcs, s, &vector, 1);
}                   

/** Wrapper for libc readv(), see rpc_recv_f type definition */
static inline ssize_t
rpc_recv_func_sys_readv(rcf_rpc_server *rpcs, int s,
                        void *buf, size_t buflen,
                        rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { buf, buflen, buf == NULL ? 0 : buflen };

    if (flags != 0)
        ERROR("Non-zero receive flags are specified for readv()");

    rpcs->use_libc_once = TRUE;
    return rpc_readv(rpcs, s, &vector, 1);
}

/** Wrapper for aio_read() with polling-based blocking */
static inline ssize_t 
rpc_recv_func_aio_read_poll(rcf_rpc_server *rpcs, int s,
                            void *buf, size_t buflen, 
                            rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for aio_read()");
        
    return rpc_aio_read_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_POLL);
}                   

/** Wrapper for aio_read() with blocking using aio_suspend() */
static inline ssize_t 
rpc_recv_func_aio_read_suspend(rcf_rpc_server *rpcs, int s,
                               void *buf, size_t buflen, 
                               rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for aio_read()");
        
    return rpc_aio_read_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_SUSPEND);
}                   

/** Wrapper for aio_read() with blocking using suspending on signal */
static inline ssize_t 
rpc_recv_func_aio_read_signal(rcf_rpc_server *rpcs, int s,
                              void *buf, size_t buflen, 
                              rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for aio_read()");
        
    return rpc_aio_read_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_SIGNAL);
}                   

/** Wrapper for aio_read() with callback-based blocking */
static inline ssize_t 
rpc_recv_func_aio_read_callback(rcf_rpc_server *rpcs, int s,
                                void *buf, size_t buflen, 
                                rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for aio_read()");
        
    return rpc_aio_read_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_CALLBACK);
}                   

/** Wrapper for aio_read() with random blocking mode */
static inline ssize_t 
rpc_recv_func_aio_read(rcf_rpc_server *rpcs, int s,
                       void *buf, size_t buflen, 
                       rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero receive flags are specified for aio_read()");
        
    return rpc_aio_read_blk(rpcs, s, buf, buflen, 
                            rand_range(TARPC_AIO_BLK_SUSPEND, 
                                       TARPC_AIO_BLK_CALLBACK));
}                   



/** Map function name to wrapper with generic prototype */
static inline rpc_recv_f 
rpc_recv_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "recv") == 0)
        return rpc_recv;
    else if (strcmp(func_name, "recvfrom") == 0)
        return rpc_recv_func_recvfrom;
    else if (strcmp(func_name, "recvmsg") == 0)
        return rpc_recv_func_recvmsg;
    else if (strcmp(func_name, "onload_zc_recv") == 0)
        return rpc_recv_func_onload_zc_recv;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_zc") == 0)
        return rpc_recv_func_hlrx_recv_zc;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_copy") == 0)
        return rpc_recv_func_hlrx_recv_copy;
    else if (strcmp(func_name, "recvmmsg") == 0)
        return rpc_recv_func_recvmmsg;
    else if (strcmp(func_name, "read") == 0)
        return rpc_recv_func_read;
    else if (strcmp(func_name, "sys_read") == 0)
        return rpc_recv_func_sys_read;
    else if (strcmp(func_name, "readv") == 0)
        return rpc_recv_func_readv;
    else if (strcmp(func_name, "sys_readv") == 0)
        return rpc_recv_func_sys_readv;
    else if (strcmp(func_name, "aio_read_poll") == 0)
        return rpc_recv_func_aio_read_poll;
    else if (strcmp(func_name, "aio_read_suspend") == 0)
        return rpc_recv_func_aio_read_suspend;
    else if (strcmp(func_name, "aio_read_signal") == 0)
        return rpc_recv_func_aio_read_signal;
    else if (strcmp(func_name, "aio_read_callback") == 0)
        return rpc_recv_func_aio_read_callback;
    else if (strcmp(func_name, "aio_read") == 0)
        return rpc_recv_func_aio_read;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_recv_func_name(rpc_recv_f func)
{
    if (func == rpc_recv)
        return "recv";
    else if (func == rpc_recv_func_recvfrom)
        return "recvfrom";
    else if (func == rpc_recv_func_recvmsg)
        return "recvmsg";
    else if (func == rpc_recv_func_onload_zc_recv)
        return "onload_zc_recv";
    else if (func == rpc_recv_func_hlrx_recv_zc)
        return "onload_zc_hlrx_recv_zc";
    else if (func == rpc_recv_func_hlrx_recv_copy)
        return "onload_zc_hlrx_recv_copy";
    else if (func == rpc_recv_func_recvmmsg)
        return "recvmmsg";
    else if (func == rpc_recv_func_read)
        return "read";
    else if (func == rpc_recv_func_sys_read)
        return "sys_read";
    else if (func == rpc_recv_func_readv)
        return "readv";
    else if (func == rpc_recv_func_sys_readv)
        return "sys_readv";
    else if (func == rpc_recv_func_aio_read_poll)
        return "aio_read_poll";
    else if (func == rpc_recv_func_aio_read_suspend)
        return "aio_read_suspend";
    else if (func == rpc_recv_func_aio_read_signal)
        return "aio_read_signal";
    else if (func == rpc_recv_func_aio_read_callback)
        return "aio_read_callback";
    else if (func == rpc_recv_func_aio_read)
        return "aio_read";
    else
        return "(unknown)";
}

/** Get "func" parameter (for receive functions only) */
#define TEST_GET_RECV_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_recv_func_by_string(str_val)) == NULL)     \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)

/** 
 * Generic prototype for RPC send functions 
 *
 * @param rpcs          RPC server handle
 * @param s             file descriptor
 * @param buf           buffer with data to be sent
 * @param len           data length
 * @param flags         send flags (RPC_MSG_*)
 *
 * @return -1 (failure) or number of sent bytes
 */
typedef ssize_t (*rpc_send_f)(rcf_rpc_server *rpcs, int s,
                              const void *buf, size_t len, 
                              rpc_send_recv_flags flags);

/** Wrapper for sendto(), see rpc_send_f type definition */
static inline ssize_t 
rpc_send_func_sendto(rcf_rpc_server *rpcs, int s,
                     const void *buf, size_t buflen, 
                     rpc_send_recv_flags flags)
{
    return rpc_sendto(rpcs, s, buf, buflen, flags, NULL);
}                   

/** Wrapper for sendmsg(), see rpc_send_f type definition */
static inline ssize_t 
rpc_send_func_sendmsg(rcf_rpc_server *rpcs, int s,
                      const void *buf, size_t buflen, 
                      rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { (void *)buf, buflen, 
                                buf == NULL ? 0 : buflen };
    rpc_msghdr       msg;
    
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_sendmsg(rpcs, s, &msg, flags);
}

/** Wrapper for sendmmsg(), see rpc_send_f type definition */
static inline ssize_t 
rpc_send_func_sendmmsg(rcf_rpc_server *rpcs, int s,
                       const void *buf, size_t buflen, 
                       rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { (void *)buf, buflen, 
                                buf == NULL ? 0 : buflen };

    struct rpc_mmsghdr   mmsg_hdr;
    rpc_msghdr          *msg = &mmsg_hdr.msg_hdr;
    int                  rc;
    
    memset(&mmsg_hdr, 0, sizeof(mmsg_hdr));
    msg->msg_iov = &vector;
    msg->msg_iovlen = msg->msg_riovlen = 1;

    if ((rc = rpc_sendmmsg_alt(rpcs, s, &mmsg_hdr, 1, flags)) < 0)
        return -1;

    return mmsg_hdr.msg_len;
}

/**
 * Maximum length of single IOV buffer passed to
 * onload_zc_send().
 * TODO: Substitute 1000 by onload constant.
 */
#define SOCKTS_ONLOAD_ZC_SEND_MAX_IOV_LEN  1000

/**
 * Generic wrapper allowing to call onload_zc_send() like send().
 *
 * @param rpcs          RPC server handle.
 * @param s             Socket FD.
 * @param buf           Buffer with data to send.
 * @param buflen        Length of the buffer.
 * @param flags         Flags to pass to onload_zc_send().
 * @param use_reg_bufs  If @c TRUE, use onload_zc_register_buffers()
 *                      instead of onload_zc_alloc_buffers().
 *
 * @return Number of bytes sent on success, negative value on failure.
 */
static inline ssize_t
rpc_send_func_onload_zc_send_gen(rcf_rpc_server *rpcs, int s,
                                 const void *buf, size_t buflen,
                                 rpc_send_recv_flags flags,
                                 te_bool use_reg_bufs)
{
    unsigned    max_len = SOCKTS_ONLOAD_ZC_SEND_MAX_IOV_LEN;
    unsigned    iov_len = 0;
    unsigned    total = 0;
    unsigned    i = 0;

    struct rpc_iovec vector[RCF_RPC_MAX_IOVEC];
    rpc_msghdr       msg;

    if (buf == NULL || buflen == 0)
    {
        iov_len = 1;
        vector[0].iov_base = (void *)buf;
        vector[0].iov_len = buflen;
        vector[0].iov_rlen = (buf == NULL) ? 0 : 1;
    }
    else
    {
        while (total != buflen)
        {
            vector[i].iov_base = (void *)buf + total;
            vector[i].iov_rlen = (buflen - total > max_len) ?
                max_len : buflen - total;
            vector[i].iov_len = vector[i].iov_rlen;
            total += vector[i].iov_rlen;
            i++;
        }
        iov_len = i;
    }
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = iov_len;

    return rpc_simple_zc_send_gen_msg(rpcs, s, &msg, flags, -1,
                                      use_reg_bufs);
}

/**
 * Wrapper for onload_zc_send() used with onload_zc_alloc_buffers(),
 * see rpc_send_f type definition.
 */
static inline ssize_t
rpc_send_func_onload_zc_send(rcf_rpc_server *rpcs, int s,
                             const void *buf, size_t buflen,
                             rpc_send_recv_flags flags)
{
    return rpc_send_func_onload_zc_send_gen(rpcs, s, buf, buflen, flags,
                                            FALSE);
}

/**
 * Wrapper for onload_zc_send() used with onload_zc_register_buffers(),
 * see rpc_send_f type definition.
 */
static inline ssize_t
rpc_send_func_onload_zc_send_user_buf(rcf_rpc_server *rpcs, int s,
                                         const void *buf, size_t buflen,
                                         rpc_send_recv_flags flags)
{
    return rpc_send_func_onload_zc_send_gen(rpcs, s, buf, buflen, flags,
                                            TRUE);
}

/** Wrapper for write(), see rpc_send_f type definition */
static inline ssize_t 
rpc_send_func_write(rcf_rpc_server *rpcs, int s,
                    const void *buf, size_t buflen, 
                    rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for write()");
        
    return rpc_write(rpcs, s, buf, buflen);
}                   

/** Wrapper for libc write(), see rpc_send_f type definition */
static inline ssize_t
rpc_send_func_sys_write(rcf_rpc_server *rpcs, int s,
                        const void *buf, size_t buflen,
                        rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for write()");

    rpcs->use_libc_once = TRUE;
    return rpc_write(rpcs, s, buf, buflen);
}

/** Wrapper for writev(), see rpc_send_f type definition */
static inline ssize_t 
rpc_send_func_writev(rcf_rpc_server *rpcs, int s,
                     const void *buf, size_t buflen, 
                     rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { (void *)buf, buflen, 
                                buf == NULL ? 0 : buflen };
    
    if (flags != 0)
        ERROR("Non-zero send flags are specified for writev()");
        
    return rpc_writev(rpcs, s, &vector, 1);
}                   

/** Wrapper for template_send(), see rpc_send_f type definition */
static inline ssize_t
rpc_send_func_template_send(rcf_rpc_server *rpcs, int s,
                           const void *buf, size_t buflen,
                            rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { (void *)buf, buflen,
                                buf == NULL ? 0 : buflen };

    return rpc_template_send(rpcs, s, &vector, 1, 1, flags);
}

/** Wrapper for libc writev(), see rpc_send_f type definition */
static inline ssize_t
rpc_send_func_sys_writev(rcf_rpc_server *rpcs, int s,
                         const void *buf, size_t buflen,
                         rpc_send_recv_flags flags)
{
    struct rpc_iovec vector = { (void *)buf, buflen,
                                buf == NULL ? 0 : buflen };

    if (flags != 0)
        ERROR("Non-zero send flags are specified for writev()");

    rpcs->use_libc_once = TRUE;
    return rpc_writev(rpcs, s, &vector, 1);
}

/** Wrapper for aio_write() with polling-based blocking */
static inline ssize_t 
rpc_send_func_aio_write_poll(rcf_rpc_server *rpcs, int s,
                             const void *buf, size_t buflen, 
                             rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for aio_write()");
        
    return rpc_aio_write_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_POLL);
}                   

/** Wrapper for aio_write() with blocking using aio_suspend() */
static inline ssize_t 
rpc_send_func_aio_write_suspend(rcf_rpc_server *rpcs, int s,
                                const void *buf, size_t buflen, 
                                rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for aio_write()");
        
    return rpc_aio_write_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_SUSPEND);
}                   

/** Wrapper for aio_write() with blocking using suspending on signal */
static inline ssize_t 
rpc_send_func_aio_write_signal(rcf_rpc_server *rpcs, int s,
                               const void *buf, size_t buflen, 
                               rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for aio_write()");
        
    return rpc_aio_write_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_SIGNAL);
}                   

/** Wrapper for aio_write() with random blocking mode */
static inline ssize_t 
rpc_send_func_aio_write(rcf_rpc_server *rpcs, int s,
                        const void *buf, size_t buflen, 
                        rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for aio_write()");
        
    return rpc_aio_write_blk(rpcs, s, buf, buflen, 
                             rand_range(TARPC_AIO_BLK_SUSPEND, 
                                        TARPC_AIO_BLK_CALLBACK));
}                   

/** Wrapper for aio_write() with callback-based blocking */
static inline ssize_t 
rpc_send_func_aio_write_callback(rcf_rpc_server *rpcs, int s,
                                 const void *buf, size_t buflen, 
                                 rpc_send_recv_flags flags)
{
    if (flags != 0)
        ERROR("Non-zero send flags are specified for aio_write()");
        
    return rpc_aio_write_blk(rpcs, s, buf, buflen, TARPC_AIO_BLK_CALLBACK);
}

static inline ssize_t
rpc_send_func_od_send_raw(rcf_rpc_server *rpcs, int s,
                           const void *buf, size_t buflen,
                            rpc_send_recv_flags flags)
{
    return rpc_od_send_raw(rpcs, s, buf, buflen, flags);
}

static inline ssize_t
rpc_send_func_od_send(rcf_rpc_server *rpcs, int s,
                           const void *buf, size_t buflen,
                            rpc_send_recv_flags flags)
{
    return rpc_od_send(rpcs, s, buf, buflen, flags);
}

/** Map function name to wrapper with generic prototype */
static inline rpc_send_f 
rpc_send_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "send") == 0)
        return rpc_send;
    else if (strcmp(func_name, "sendto") == 0)
        return rpc_send_func_sendto;
    else if (strcmp(func_name, "sendmsg") == 0)
        return rpc_send_func_sendmsg;
    else if (strcmp(func_name, "sendmmsg") == 0)
        return rpc_send_func_sendmmsg;
    else if (strcmp(func_name, "onload_zc_send") == 0)
        return rpc_send_func_onload_zc_send;
    else if (strcmp(func_name, "onload_zc_send_user_buf") == 0)
        return rpc_send_func_onload_zc_send_user_buf;
    else if (strcmp(func_name, "write") == 0)
        return rpc_send_func_write;
    else if (strcmp(func_name, "sys_write") == 0)
        return rpc_send_func_sys_write;
    else if (strcmp(func_name, "writev") == 0)
        return rpc_send_func_writev;
    else if (strcmp(func_name, "sys_writev") == 0)
        return rpc_send_func_sys_writev;
    else if (strcmp(func_name, "template_send") == 0)
        return rpc_send_func_template_send;
    else if (strcmp(func_name, "aio_write_poll") == 0)
        return rpc_send_func_aio_write_poll;
    else if (strcmp(func_name, "aio_write_suspend") == 0)
        return rpc_send_func_aio_write_suspend;
    else if (strcmp(func_name, "aio_write_signal") == 0)
        return rpc_send_func_aio_write_signal;
    else if (strcmp(func_name, "aio_write_callback") == 0)
        return rpc_send_func_aio_write_callback;
    else if (strcmp(func_name, "aio_write") == 0)
        return rpc_send_func_aio_write;
    else if (strcmp(func_name, "od_send") == 0)
        return rpc_send_func_od_send;
    else if (strcmp(func_name, "od_send_raw") == 0)
        return rpc_send_func_od_send_raw;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_send_func_name(rpc_send_f func)
{
    if (func == rpc_send)
        return "send";
    else if (func == rpc_send_func_sendto)
        return "sendto";
    else if (func == rpc_send_func_sendmsg)
        return "sendmsg";
    else if (func == rpc_send_func_sendmmsg)
        return "sendmmsg";
    else if (func == rpc_send_func_onload_zc_send)
        return "onload_zc_send";
    else if (func == rpc_send_func_onload_zc_send_user_buf)
        return "onload_zc_send_user_buf";
    else if (func == rpc_send_func_write)
        return "write";
    else if (func == rpc_send_func_sys_write)
        return "sys_write";
    else if (func == rpc_send_func_writev)
        return "writev";
    else if (func == rpc_send_func_sys_writev)
        return "sys_writev";
    else if (func == rpc_send_func_template_send)
        return "template_send";
    else if (func == rpc_send_func_aio_write_poll)
        return "aio_write_poll";
    else if (func == rpc_send_func_aio_write_suspend)
        return "aio_write_suspend";
    else if (func == rpc_send_func_aio_write_signal)
        return "aio_write_signal";
    else if (func == rpc_send_func_aio_write_callback)
        return "aio_write_callback";
    else if (func == rpc_send_func_aio_write)
        return "aio_write";
    else if (func == rpc_send_func_od_send)
        return "od_send";
    else if (func == rpc_send_func_od_send_raw)
        return "od_send_raw";
    else
        return "(unknown)";
}


/** Get "func" parameter (for send functions only) */
#define TEST_GET_SEND_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_send_func_by_string(str_val)) == NULL)     \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)

/** 
 * Get "func" parameter.
 *
 * @param _var_name     name of the test parameter/function variable
 * @param _is_send      boolean variable, is set to TRUE if the 
 *                      send function is specified in the parameter
 *                      abd to FALSE otherwise
 */
#define TEST_GET_FUNC(_var_name, _is_send) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        _is_send = TRUE;                                                \
        if ((_var_name =                                                \
                 (void *)rpc_send_func_by_string(str_val)) == NULL &&   \
            (_is_send = FALSE, _var_name =                              \
                (void *)rpc_recv_func_by_string(str_val)) == NULL)      \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)


/** 
 * Generic prototype for RPC scatter receive functions 
 *
 * @param rpcs          RPC server handle
 * @param s             file descriptor
 * @param vector        pointer to a vector of receive buffers
 * @param count         number of buffers in the vector
 *
 * @return -1 (failure) or number of received bytes
 */
typedef ssize_t (*rpc_scatter_read_f)(rcf_rpc_server *rpcs, 
                                      int s,
                                      struct rpc_iovec *vector,
                                      size_t count);

/** Wrapper for readv(), see rpc_scatter_read_f type definition */
static inline ssize_t 
rpc_scatter_read_func_readv(rcf_rpc_server *rpcs, int s,
                            struct rpc_iovec *vector,
                            size_t count)
{
    return rpc_readv(rpcs, s, vector, count);
}                   

/** Wrapper for libc readv(), see rpc_scatter_read_f type definition */
static inline ssize_t 
rpc_scatter_read_func_sys_readv(rcf_rpc_server *rpcs, int s,
                                struct rpc_iovec *vector,
                                size_t count)
{
    rpcs->use_libc_once = TRUE;
    return rpc_readv(rpcs, s, vector, count);
}

/** Wrapper for recvmsg(), see rpc_scatter_read_f type definition */
static inline ssize_t 
rpc_scatter_read_func_recvmsg(rcf_rpc_server *rpcs, int s,
                              struct rpc_iovec *vector, 
                              size_t count)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;
    
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_recvmsg(rpcs, s, &msg, flags);
}

/**
 * Wrapper for onload_zc_hlrx_recv_zc(), see rpc_scatter_read_f type
 * definition
 */
static inline ssize_t
rpc_scatter_read_func_hlrx_recv_zc(rcf_rpc_server *rpcs, int s,
                                   struct rpc_iovec *vector,
                                   size_t count)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_simple_hlrx_recv_zc(rpcs, s, &msg, flags, TRUE);
}

/**
 * Wrapper for onload_zc_hlrx_recv_copy(), see rpc_scatter_read_f type
 * definition
 */
static inline ssize_t
rpc_scatter_read_func_hlrx_recv_copy(rcf_rpc_server *rpcs, int s,
                                     struct rpc_iovec *vector,
                                     size_t count)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_simple_hlrx_recv_copy(rpcs, s, &msg, flags, TRUE);
}

/** Wrapper for onload_zc_recv(), see rpc_scatter_read_f type definition */
static inline ssize_t
rpc_scatter_read_func_onload_zc_recv(rcf_rpc_server *rpcs, int s,
                                     struct rpc_iovec *vector,
                                     size_t count)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_simple_zc_recv(rpcs, s, &msg, flags);
}

/** Wrapper for recvmmsg(), see rpc_scatter_read_f type definition */
static inline ssize_t
rpc_scatter_read_func_recvmmsg(rcf_rpc_server *rpcs, int s,
                               struct rpc_iovec *vector,
                               size_t count)
{
    struct rpc_mmsghdr   mmsghdr;
    rpc_msghdr           *msg = &mmsghdr.msg_hdr;
    rpc_send_recv_flags  flags;

    int rc;

    memset(msg, 0, sizeof(*msg));
    msg->msg_iov = vector;
    msg->msg_iovlen = msg->msg_riovlen = count;
    flags = 0x0;

    if ((rc = rpc_recvmmsg_alt(rpcs, s, &mmsghdr, 1, flags, NULL)) == -1)
        return -1;

    return mmsghdr.msg_len;
}

/** Map function name to wrapper with generic prototype */
static inline rpc_scatter_read_f 
rpc_scatter_read_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "recvmsg") == 0)
        return rpc_scatter_read_func_recvmsg;
    else if (strcmp(func_name, "onload_zc_recv") == 0)
        return rpc_scatter_read_func_onload_zc_recv;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_zc") == 0)
        return rpc_scatter_read_func_hlrx_recv_zc;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_copy") == 0)
        return rpc_scatter_read_func_hlrx_recv_copy;
    else if (strcmp(func_name, "readv") == 0)
        return rpc_scatter_read_func_readv;
    else if (strcmp(func_name, "sys_readv") == 0)
        return rpc_scatter_read_func_sys_readv;
    else if (strcmp(func_name, "recvmmsg") == 0)
        return rpc_scatter_read_func_recvmmsg;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_scatter_read_func_name(rpc_scatter_read_f func)
{
    if (func == rpc_scatter_read_func_recvmsg)
        return "recvmsg";
    else if (func == rpc_scatter_read_func_onload_zc_recv)
        return "onload_zc_recv";
    else if (func == rpc_scatter_read_func_hlrx_recv_zc)
        return "onload_zc_hlrx_recv_zc";
    else if (func == rpc_scatter_read_func_hlrx_recv_copy)
        return "onload_zc_hlrx_recv_copy";
    else if (func == rpc_scatter_read_func_readv)
        return "readv";
    else if (func == rpc_scatter_read_func_sys_readv)
        return "sys_readv";
    else if (func == rpc_scatter_read_func_recvmmsg)
        return "recvmmsg";
    else
        return "(unknown)";
}

/** Get "func" parameter (for scatter read functions only) */
#define TEST_GET_SCATTER_READ_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_scatter_read_func_by_string(str_val))      \
                                                           == NULL)     \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)

/** 
 * Generic prototype for RPC msg receive functions 
 *
 * @param rpcs   RPC server handle
 * @param s      file descriptor
 * @param msg    pointer to a @b rpc_msghdr structure that hold the
 *               received message 
 * @param flags  bitwise OR of zero or more of the flags; 
 *               see @b rpc_recv for more information
 *
 * @return -1 (failure) or number of received bytes
 */
typedef ssize_t (*rpc_msg_read_f)(rcf_rpc_server *rpcs,
                                      int s,
                                      struct rpc_msghdr *msg,
                                      rpc_send_recv_flags flags);

/** Wrapper for recvmsg(), see rpc_msg_read_f type definition */
static inline ssize_t
rpc_msg_read_func_recvmsg(rcf_rpc_server *rpcs,
                          int s, struct rpc_msghdr *msg,
                          rpc_send_recv_flags flags)
{
    return rpc_recvmsg(rpcs, s, msg, flags);
}

/**
 * Wrapper for onload_zc_hlrx_recv_zc(), see rpc_msg_read_f type
 * definition
 */
static inline ssize_t
rpc_msg_read_func_hlrx_recv_zc(rcf_rpc_server *rpcs,
                               int s, struct rpc_msghdr *msg,
                               rpc_send_recv_flags flags)
{
    return rpc_simple_hlrx_recv_zc(rpcs, s, msg, flags, TRUE);
}

/**
 * Wrapper for onload_zc_hlrx_recv_copy(), see rpc_msg_read_f type
 * definition
 */
static inline ssize_t
rpc_msg_read_func_hlrx_recv_copy(rcf_rpc_server *rpcs,
                                 int s, struct rpc_msghdr *msg,
                                 rpc_send_recv_flags flags)
{
    return rpc_simple_hlrx_recv_copy(rpcs, s, msg, flags, TRUE);
}

/** Wrapper for onload_zc_recv(), see rpc_msg_read_f type definition */
static inline ssize_t
rpc_msg_read_func_onload_zc_recv(rcf_rpc_server *rpcs,
                                 int s, struct rpc_msghdr *msg,
                                 rpc_send_recv_flags flags)
{
    return rpc_simple_zc_recv(rpcs, s, msg, flags);
}

/** Wrapper for recvmmsg(), see rpc_msg_read_f type definition */
static inline ssize_t
rpc_msg_read_func_recvmmsg(rcf_rpc_server *rpcs,
                           int s, struct rpc_msghdr *msg,
                           rpc_send_recv_flags flags)
{
    struct rpc_mmsghdr mmsghdr;
    struct rpc_msghdr *tmp_msg = &mmsghdr.msg_hdr;
    int rc;

    memcpy(tmp_msg, msg, sizeof(*msg));
    if ((rc = rpc_recvmmsg_alt(rpcs, s, &mmsghdr, 1, flags, NULL)) == -1)
        return -1;
    memcpy(msg, tmp_msg, sizeof(*msg));

    return mmsghdr.msg_len;
}

/** Map function name to wrapper with generic prototype */
static inline rpc_msg_read_f
rpc_msg_read_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "recvmsg") == 0)
        return rpc_msg_read_func_recvmsg;
    else if (strcmp(func_name, "onload_zc_recv") == 0)
        return rpc_msg_read_func_onload_zc_recv;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_zc") == 0)
        return rpc_msg_read_func_hlrx_recv_zc;
    else if (strcmp(func_name, "onload_zc_hlrx_recv_copy") == 0)
        return rpc_msg_read_func_hlrx_recv_copy;
    else if (strcmp(func_name, "recvmmsg") == 0)
        return rpc_msg_read_func_recvmmsg;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_msg_read_func_name(rpc_msg_read_f func)
{
    if (func == rpc_msg_read_func_recvmsg)
        return "recvmsg";
    else if (func == rpc_msg_read_func_onload_zc_recv)
        return "onload_zc_recv";
    else if (func == rpc_msg_read_func_hlrx_recv_zc)
        return "onload_zc_hlrx_recv_zc";
    else if (func == rpc_msg_read_func_hlrx_recv_copy)
        return "onload_zc_hlrx_recv_copy";
    else if (func == rpc_msg_read_func_recvmmsg)
        return "recvmmsg";
    else
        return "(unknown)";
}

/** Get "func" parameter (for msg read functions only) */
#define TEST_GET_MSG_READ_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_msg_read_func_by_string(str_val))          \
                                                           == NULL)     \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)

/** 
 * Generic prototype for RPC gather write functions 
 *
 * @param rpcs          RPC server handle
 * @param s             file descriptor
 * @param vector        pointer to a vector of receive buffers
 * @param count         number of buffers in the vector
 *
 * @return -1 (failure) or number of received bytes
 */
typedef ssize_t (*rpc_gather_write_f)(rcf_rpc_server *rpcs, 
                                      int s,
                                      struct rpc_iovec *vector,
                                      size_t count);

/** Wrapper for writev(), see rpc_gather_write_f type definition */
static inline ssize_t 
rpc_gather_write_func_writev(rcf_rpc_server *rpcs, int s,
                             struct rpc_iovec *vector,
                             size_t count)
{
    return rpc_writev(rpcs, s, vector, count);
}                   

/** Wrapper for template_send(), see rpc_gather_write_f type definition */
static inline ssize_t 
rpc_gather_write_func_template_send(rcf_rpc_server *rpcs, int s,
                                    struct rpc_iovec *vector,
                                    size_t count)
{
    return rpc_template_send(rpcs, s, vector, count, count, 0);
}


/** Wrapper for libc writev(), see rpc_gather_write_f type definition */
static inline ssize_t 
rpc_gather_write_func_sys_writev(rcf_rpc_server *rpcs, int s,
                                 struct rpc_iovec *vector,
                                 size_t count)
{
    rpcs->use_libc_once = TRUE;
    return rpc_writev(rpcs, s, vector, count);
}

/** Wrapper for sendmsg(), see rpc_gather_write_f type definition */
static inline ssize_t 
rpc_gather_write_func_sendmsg(rcf_rpc_server *rpcs, int s,
                              struct rpc_iovec *vector, 
                              size_t count)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;
    
    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_sendmsg(rpcs, s, &msg, flags);
}

/** Wrapper for sendmmsg(), see rpc_gather_write_f type definition */
static inline ssize_t 
rpc_gather_write_func_sendmmsg(rcf_rpc_server *rpcs, int s,
                               struct rpc_iovec *vector, 
                               size_t count)
{
    struct rpc_mmsghdr   mmsg_hdr;
    rpc_msghdr          *msg = &mmsg_hdr.msg_hdr;
    int                  rc;
    rpc_send_recv_flags  flags;
    
    memset(&mmsg_hdr, 0, sizeof(mmsg_hdr));
    msg->msg_iov = vector;
    msg->msg_iovlen = msg->msg_riovlen = count;
    flags = 0x0;

    if ((rc = rpc_sendmmsg_alt(rpcs, s, &mmsg_hdr, 1, flags)) < 0)
        return -1;

    return mmsg_hdr.msg_len;
}

/**
 * Generic wrapper allowing to call onload_zc_send() like writev().
 *
 * @param rpcs          RPC server handle.
 * @param s             Socket FD.
 * @param vector        Array of iovecs.
 * @param count         Number of iovecs.
 * @param use_reg_bufs  If @c TRUE, use onload_zc_register_buffers()
 *                      instead of onload_zc_alloc_buffers().
 *
 * @return Number of bytes sent on success, negative value on failure.
 */
static inline ssize_t
rpc_gather_write_func_onload_zc_send_gen(rcf_rpc_server *rpcs, int s,
                                         struct rpc_iovec *vector,
                                         size_t count, te_bool use_reg_bufs)
{
    rpc_msghdr           msg;
    rpc_send_recv_flags  flags;

    memset(&msg, 0, sizeof(msg));
    msg.msg_iov = vector;
    msg.msg_iovlen = msg.msg_riovlen = count;
    flags = 0x0;

    return rpc_simple_zc_send_gen_msg(rpcs, s, &msg, flags, -1,
                                      use_reg_bufs);
}

/**
 * Wrapper for onload_zc_send() used with onload_zc_alloc_buffers(),
 * see rpc_gather_write_f type definition.
 */
static inline ssize_t
rpc_gather_write_func_onload_zc_send(rcf_rpc_server *rpcs, int s,
                                     struct rpc_iovec *vector,
                                     size_t count)
{
    return rpc_gather_write_func_onload_zc_send_gen(rpcs, s, vector, count,
                                                    FALSE);
}


/**
 * Wrapper for onload_zc_send() used with onload_zc_register_buffers(),
 * see rpc_gather_write_f type definition.
 */
static inline ssize_t
rpc_gather_write_func_onload_zc_send_user_buf(rcf_rpc_server *rpcs, int s,
                                              struct rpc_iovec *vector,
                                              size_t count)
{
    return rpc_gather_write_func_onload_zc_send_gen(rpcs, s, vector, count,
                                                    TRUE);
}

/** Wrapper for od_send_iov(), see rpc_gather_write_f type definition */
static inline ssize_t
rpc_gather_write_func_od_send_iov(rcf_rpc_server *rpcs, int s,
                                  struct rpc_iovec *vector, size_t count)
{
    return rpc_od_send_iov(rpcs, s, vector, count, 0);
}

/** Wrapper for od_send_iov_raw(), see rpc_gather_write_f type definition */
static inline ssize_t
rpc_gather_write_func_od_send_iov_raw(rcf_rpc_server *rpcs, int s,
                                  struct rpc_iovec *vector, size_t count)
{
    return rpc_od_send_iov_raw(rpcs, s, vector, count, 0);
}


/** Map function name to wrapper with generic prototype */
static inline rpc_gather_write_f 
rpc_gather_write_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "sendmsg") == 0)
        return rpc_gather_write_func_sendmsg;
    else if (strcmp(func_name, "sendmmsg") == 0)
        return rpc_gather_write_func_sendmmsg;
    else if (strcmp(func_name, "onload_zc_send") == 0)
        return rpc_gather_write_func_onload_zc_send;
    else if (strcmp(func_name, "onload_zc_send_user_buf") == 0)
        return rpc_gather_write_func_onload_zc_send_user_buf;
    else if (strcmp(func_name, "writev") == 0)
        return rpc_gather_write_func_writev;
    else if (strcmp(func_name, "sys_writev") == 0)
        return rpc_gather_write_func_sys_writev;
    else if (strcmp(func_name, "template_send") == 0)
        return rpc_gather_write_func_template_send;
    else if (strcmp(func_name, "od_send_iov") == 0)
        return rpc_gather_write_func_od_send_iov;
    else if (strcmp(func_name, "od_send_iov_raw") == 0)
        return rpc_gather_write_func_od_send_iov_raw;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_gather_write_func_name(rpc_gather_write_f func)
{
    if (func == rpc_gather_write_func_sendmsg)
        return "sendmsg";
    else if (func == rpc_gather_write_func_sendmmsg)
        return "sendmmsg";
    else if (func == rpc_gather_write_func_onload_zc_send)
        return "onload_zc_send";
    else if (func == rpc_gather_write_func_onload_zc_send_user_buf)
        return "onload_zc_send_user_buf";
    else if (func == rpc_gather_write_func_writev)
        return "writev";
    else if (func == rpc_gather_write_func_sys_writev)
        return "sys_writev";
    else if (func == rpc_gather_write_func_template_send)
        return "template_send";
    else
        return "(unknown)";
}

/** Get "func" parameter (for scatter write functions only) */
#define TEST_GET_GATHER_WRITE_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_gather_write_func_by_string(str_val))      \
                                                           == NULL)     \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)


/** 
 * Generic prototype for RPC sendto functions 
 *
 * @param rpcs          RPC server handle
 * @param s             file descriptor
 * @param buf           buffer with data to be sent
 * @param len           data length
 * @param flags         send flags (RPC_MSG_*)
 * @param to            destination address pointer
 * @param tolen         length of the destination address
 *
 * @return -1 (failure) or number of sent bytes
 */
typedef ssize_t (*rpc_sendto_f)(rcf_rpc_server *rpcs, int s,
                                const void *buf, size_t len, 
                                rpc_send_recv_flags flags,
                                const struct sockaddr *to);

/** Wrapper for sendmsg(), see rpc_sendto_f type definition */
static inline ssize_t 
rpc_sendto_func_sendmsg(rcf_rpc_server *rpcs, int s,
                        const void *buf, size_t buflen, 
                        rpc_send_recv_flags flags,
                        const struct sockaddr *to)
{
    struct rpc_iovec vector = { (void *)buf, buflen, 
                                buf == NULL ? 0 : buflen };
    rpc_msghdr       msg;
    
    memset(&msg, 0, sizeof(msg));
    msg.msg_name = SA(to);
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_sendmsg(rpcs, s, &msg, flags);
}

/** Wrapper for sendmmsg(), see rpc_sendto_f type definition */
static inline ssize_t 
rpc_sendto_func_sendmmsg(rcf_rpc_server *rpcs, int s,
                         const void *buf, size_t buflen, 
                         rpc_send_recv_flags flags,
                         const struct sockaddr *to)
{
    struct rpc_iovec vector = { (void *)buf, buflen, 
                                buf == NULL ? 0 : buflen };

    struct rpc_mmsghdr   mmsg_hdr;
    rpc_msghdr          *msg = &mmsg_hdr.msg_hdr;
    int                  rc;
    
    memset(&mmsg_hdr, 0, sizeof(mmsg_hdr));
    msg->msg_name = SA(to);
    msg->msg_iov = &vector;
    msg->msg_iovlen = msg->msg_riovlen = 1;

    if ((rc = rpc_sendmmsg_alt(rpcs, s, &mmsg_hdr, 1, flags)) < 0)
        return -1;

    return mmsg_hdr.msg_len;
}

/**
 * Generic wrapper allowing to call onload_zc_send() like sendto().
 *
 * @param rpcs          RPC server handle.
 * @param s             Socket FD.
 * @param buf           Buffer with data to send.
 * @param buflen        Length of the buffer.
 * @param flags         Flags to pass to onload_zc_send().
 * @param to            Destination address.
 * @param use_reg_bufs  If @c TRUE, use onload_zc_register_buffers()
 *                      instead of onload_zc_alloc_buffers().
 *
 * @return Number of bytes sent on success, negative value on failure.
 */
static inline ssize_t
rpc_sendto_func_onload_zc_send_gen(rcf_rpc_server *rpcs, int s,
                                   const void *buf, size_t buflen,
                                   rpc_send_recv_flags flags,
                                   const struct sockaddr *to,
                                   te_bool use_reg_bufs)
{
    struct rpc_iovec vector = { (void *)buf, buflen,
                                buf == NULL ? 0 : buflen };
    rpc_msghdr       msg;

    memset(&msg, 0, sizeof(msg));
    msg.msg_name = SA(to);
    msg.msg_iov = &vector;
    msg.msg_iovlen = msg.msg_riovlen = 1;

    return rpc_simple_zc_send_gen_msg(rpcs, s, &msg, flags, -1,
                                      use_reg_bufs);
}

/**
 * Wrapper for onload_zc_send() used with onload_zc_alloc_buffers(),
 * see rpc_sendto_f type definition.
 */
static inline ssize_t
rpc_sendto_func_onload_zc_send(rcf_rpc_server *rpcs, int s,
                               const void *buf, size_t buflen,
                               rpc_send_recv_flags flags,
                               const struct sockaddr *to)
{
    return rpc_sendto_func_onload_zc_send_gen(rpcs, s, buf, buflen,
                                              flags, to, FALSE);
}

/**
 * Wrapper for onload_zc_send() used with onload_zc_register_buffers(),
 * see rpc_sendto_f type definition.
 */
static inline ssize_t
rpc_sendto_func_onload_zc_send_user_buf(rcf_rpc_server *rpcs, int s,
                                        const void *buf, size_t buflen,
                                        rpc_send_recv_flags flags,
                                        const struct sockaddr *to)
{
    return rpc_sendto_func_onload_zc_send_gen(rpcs, s, buf, buflen,
                                              flags, to, TRUE);
}

/** Map function name to wrapper with generic prototype */
static inline rpc_sendto_f 
rpc_sendto_func_by_string(const char *func_name)
{
    if (strcmp(func_name, "sendto") == 0)
        return rpc_sendto;
    else if (strcmp(func_name, "sendmsg") == 0)
        return rpc_sendto_func_sendmsg;
    else if (strcmp(func_name, "sendmmsg") == 0)
        return rpc_sendto_func_sendmmsg;
    else if (strcmp(func_name, "onload_zc_send") == 0)
        return rpc_sendto_func_onload_zc_send;
    else if (strcmp(func_name, "onload_zc_send_user_buf") == 0)
        return rpc_sendto_func_onload_zc_send_user_buf;
    else
        return NULL;
}

/** Map function pointer to name */
static inline const char *
rpc_sendto_func_name(rpc_sendto_f func)
{
    if (func == rpc_sendto)
        return "sendto";
    else if (func == rpc_sendto_func_sendmsg)
        return "sendmsg";
    else if (func == rpc_sendto_func_sendmmsg)
        return "sendmmsg";
    else if (func == rpc_sendto_func_onload_zc_send)
        return "onload_zc_send";
    else if (func == rpc_sendto_func_onload_zc_send_user_buf)
        return "onload_zc_send_user_buf";
    else
        return "(unknown)";
}

/** Get "func" parameter (for sendto functions only) */
#define TEST_GET_SENDTO_FUNC(_var_name) \
    do {                                                                \
        const char *str_val;                                            \
                                                                        \
        str_val = test_get_param(argc, argv, #_var_name);               \
        if (str_val == NULL)                                            \
        {                                                               \
            TEST_STOP;                                                  \
        }                                                               \
        if ((_var_name = rpc_sendto_func_by_string(str_val)) == NULL)   \
        {                                                               \
            TEST_FAIL("Incorrect %s parameter %s is specified",         \
                      #_var_name, str_val);                             \
        }                                                               \
    } while (0)


/** Set environment variable and restart RPC server
 *
 * @param rpcs      RPC server to set variable and restart
 * @param name      Name of the environment variable
 * @param new_val   New value to set
 * @param old_val   OUT: pointer to the old value
 *
 * @return Configurator handle to be used in @c sockts_restore_env().
 */
static inline cfg_handle
sockts_set_env_gen(rcf_rpc_server *rpcs, char *name,
                   const char *new_val, char **old_val,
                   te_bool restart)
{
    cfg_handle handle = CFG_HANDLE_INVALID;

    if (cfg_find_fmt(&handle, "/agent:%s/env:%s", rpcs->ta, name) != 0)
    {
        CHECK_RC(cfg_add_instance_fmt(&handle, CVT_STRING, new_val,
                                      "/agent:%s/env:%s", rpcs->ta, name));
        if (old_val != NULL)
            *old_val = NULL;
    }
    else
    {
        cfg_val_type val_type = CVT_STRING;

        if (old_val != NULL)
            CHECK_RC(cfg_get_instance(handle, &val_type, old_val));
        CHECK_RC(cfg_set_instance(handle, CVT_STRING, new_val));
    }

    if (restart)
        CHECK_RC(rcf_rpc_server_restart(rpcs));

    return handle;
}

static inline cfg_handle
sockts_set_env(rcf_rpc_server *rpcs, char *name,
               const char *new_val, char **old_val)
{
    return sockts_set_env_gen(rpcs, name, new_val, old_val, TRUE);
}
/** Restore environment and RPC server after @c sockts_set_env(),
 * to be called from cleanup.
 *
 * @param rpcs      Same RPC server
 * @param handle    Handle returned by @c sockts_set_env()
 * @param old_val   Old value returned by @c sockts_set_env(), consumed
 *                  here
 *
 * @note Gracefully returns if @c sockts_set_env() failed and
 * @c handle @c == @c CFG_HANDLE_INVALID.
 *
 * @return 0 on success or status code
 */
static inline int
sockts_restore_env_gen(rcf_rpc_server *rpcs, cfg_handle handle, char *old_val,
                       te_bool restart)
{
    int rc = 0;

    if (handle == CFG_HANDLE_INVALID)
        return 0;

    if (old_val == NULL)
    {
        if ((rc = cfg_del_instance(handle, FALSE)) != 0)
            return rc;
    }
    else
    {
        if ((rc = cfg_set_instance(handle, CVT_STRING, old_val)) != 0)
            return rc;
        free(old_val);
    }

    if (restart)
        rc = rcf_rpc_server_restart(rpcs);

    return 0;
}

static inline int
sockts_restore_env(rcf_rpc_server *rpcs, cfg_handle handle, char *old_val)
{
    return sockts_restore_env_gen(rpcs, handle, old_val, TRUE);
}

/** 
 * Set system console loglevel to KERN_ERR, 
 * loglevel doesn't change if ool tag @c debug is active
 * 
 * @param _pco          RPC server handle
 * @param _old_loglevel Console loglevel which was before changes
 */
#define TAPI_SYS_LOGLEVEL_DEBUG(_pco, _old_loglevel) \
do {                                                                \
    if (getenv("DEBUG_CONSOLE") == NULL)                            \
        tapi_cfg_set_loglevel_save((_pco)->ta, 3, (_old_loglevel)); \
} while (0)

/**
 * Set system console to _loglevel,
 * loglevel doesn't change if ool tag @c debug is active
 * 
 * @param _pco          RPC server handle
 * @param _loglevel     Console loglevel which should be set
 */
#define TAPI_SYS_LOGLEVEL_CANCEL_DEBUG(_pco, _loglevel) \
do {                                                             \
    if (getenv("DEBUG_CONSOLE") == NULL)                         \
        tapi_cfg_set_loglevel_save((_pco)->ta, _loglevel, NULL); \
} while (0)

/**
 * Wait for the interface to be up state
 *
 * @param rpcs          RPC server handle.
 * @param if_name       Interface name
 *
 * @return Status code.
 */
extern te_errno sockts_wait_for_if_up(rcf_rpc_server *rpcs,
                                      const char *if_name);

/**
 * Restart given interface.
 *
 * @param rpcs      RPC server handle.
 * @param if_name   interface name
 */
static inline void
sockts_restart_if(rcf_rpc_server *rpcs, const char *if_name)
{
    tapi_cfg_base_if_down(rpcs->ta, if_name);
    tapi_cfg_base_if_up(rpcs->ta, if_name);
    sockts_wait_for_if_up(rpcs, if_name);
    CFG_WAIT_CHANGES;
}

/**
 * Call sending or receiving function.
 *
 * @param rpcs      RPC server handle
 * @param func      function to call
 * @param is_send   is func sending or receiving function
 * @param s         socket descriptor
 * @param buf       pointer to buffer containing the message to be sent
 * @param len       length of the message in bytes
 * @param flags     bitwise OR of zero or more of sending/receiving flags
 *
 * @return Number of bytes sent/received, otherwise -1 when error occured
 */
static inline ssize_t 
rpc_call_send_recv(rcf_rpc_server *rpcs, 
                   void *func, te_bool is_send,
                   int s, void *buf, size_t len,
                   rpc_send_recv_flags flags)
{
    return is_send ? ((rpc_send_f)func)(rpcs, s, buf, len, flags)
                   : ((rpc_recv_f)func)(rpcs, s, buf, len, flags);
}

/**
 * Check that @p func call blocks or does not block.
 *
 * @param pco_iut   RPC server on IUT
 * @param pco_tst   RPC server on Tester
 * @param func      Function to call
 * @param is_send   Is func sending or receiving function
 * @param iut_fd    File descriptor on IUT
 * @param tst_fd    File descriptor on Tester
 * @param flag      Expected blocking state of file descriptor
 *                  (@c TRUE - it is blocking)
 * @param stage     Description of current stage
                    (used as a prefix for all verdicts)
 * @param data_size Size of data to perform checking
 */
extern void sockts_check_blocking(rcf_rpc_server *pco_iut,
                                  rcf_rpc_server *pco_tst,
                                  void *func, te_bool is_send,
                                  int iut_fd, int tst_fd,
                                  te_bool flag, size_t data_size,
                                  char *stage_fmt, ...);

/**
 * Generate connection, set RPC_SOCK_CLOEXEC and/or RPC_SOCK_NONBLOCK 
 * flag with socket() or accept4() functions if required.
 *
 * @param pco1              Handle of RPC server where to create @p s1
 *                          socket
 * @param pco2              Handle of RPC server where to create @p s2
 *                          socket
 * @param addr1             Address to bind @p s1 socket
 * @param addr2             Address to bind @p s2 socket
 * @param s1                Handle of socket 1
 * @param s2                Handle of socket 2
 * @param sock_type         Type of sockets (RPC_SOCK_STREAM,
 *                          RPC_SOCK_DGRAM)
 * @param sock_flags        Flag to be set (RPC_SOCK_CLOEXEC,
 *                          RPC_SOCK_NONBLOCK)
 * @param sf_first          Whether to use socket() to set @p sock_flags on
 *                          the first socket
 * @param sf_second         Whether to use socket() to set @p sock_flags on
 *                          the second socket
 * @param accept4_first     Whether to use accept4() to set @p sock_flags on
 *                          the first socket
 *
 * @alg if @c SOCK_STREAM is tested, connection is opened passively on
 *      @p pco1.
 * @return  0 on success, -1 otherwise
 */
extern int gen_conn_with_flags(rcf_rpc_server *pco1, rcf_rpc_server *pco2,
                               const struct sockaddr *addr1,
                               const struct sockaddr *addr2,
                               int *s1, int *s2, rpc_socket_type sock_type,
                               rpc_socket_flags sock_flags,
                               te_bool sf_first, te_bool sf_second,
                               te_bool accept4_first);

/** Wrapper allowing to call sendmmsg() like sendmsg() */
static inline ssize_t 
rpc_sendmmsg_as_sendmsg(rcf_rpc_server *rpcs, int s,
                        const struct rpc_msghdr *msg,
                        rpc_send_recv_flags flags)
{
    struct rpc_mmsghdr   mmsg_hdr;
    int                  rc;

    memset(&mmsg_hdr, 0, sizeof(mmsg_hdr));
    memcpy(&mmsg_hdr.msg_hdr, msg, sizeof(*msg));

    if ((rc = rpc_sendmmsg_alt(rpcs, s, &mmsg_hdr, 1, flags)) < 0)
        return -1;

    return mmsg_hdr.msg_len;
}

/**
 * Create file name to store infarmation about socket leakage
 *
 * @param rpcs  RPC server
 * @param suf   Name suffix
 * @param name  Name of file (OUT)
 * @param len   Length of name buffer
 */
extern void sockts_leak_file_name(rcf_rpc_server *rpcs, char *suf,
                                  char *name, size_t len);

/**
 * Save out of 'netstat -p' command to file
 *
 * @param rpcs  RPC server
 * @param name  Name of file to store
 *
 * * @return Status of the operation.
 *
 * @retval  0  on success
 * @retval -1  on failure
 */
extern int sockts_save_netstat_out(rcf_rpc_server *rpcs, char *name);

/**
 * Compare two outputs of netstat command
 *
 * @param name1  Name of the first file
 * @param name2  Name of the second file
 *
 * @return Number of new socket or -1 in case of failure
 */
extern int sockts_cmp_netstat_out(char *name1, char *name2);

/**
 * Share a socket between two processes. The processes should be located on
 * a one host.
 * 
 * @param rpcs1     RPC server of the process from which should be
 *                  copied the file descriptor
 * @param rpcs2     RPC server of the process to which should be
 *                  copied the file descriptor
 * @param sock      The socket or file descriptor to be copied
 * 
 * @return Copy of the socket
 */
extern int sockts_share_socket_2proc(rcf_rpc_server *rpcs1,
                                     rcf_rpc_server *rpcs2, int sock);

/**
 * Get the maximim limit of stacks that can be utilized.
 *
 * @param rpcs          RPC server.
 *
 * @return Stacks amount or 0 if no limit
 */
extern int sockts_get_limited_stacks(rcf_rpc_server *rpcs);

/**
 * Kill zombie stacks on the server.
 * 
 * @param rpcs          RPC server
 * @param check_only    Whether to check zombie stack
 */
extern void sockts_get_kill_zombie_stacks(rcf_rpc_server *rpcs,
                                          te_bool check_only);

static inline void
sockts_kill_zombie_stacks(rcf_rpc_server *rpcs)
{
    sockts_get_kill_zombie_stacks(rpcs, FALSE);
}

static inline void
sockts_get_zombie_stacks(rcf_rpc_server *rpcs)
{
    sockts_get_kill_zombie_stacks(rpcs, TRUE);
}

/**
 * Kill zombie stacks on the server if there is more than allowed.
 *
 * @param rpcs          RPC server
 * @param stacks_num    Max number of allowed zombie stacks
 */
extern void sockts_kill_zombie_stacks_gen(rcf_rpc_server *rpcs,
                                          unsigned int stacks_num);

/**
 * Wrapper for sockts_kill_zombie_stacks_gen that
 * uses the number of allowed zombie stacks obtained
 * from the SF_V5_MAX_ALLOWED_ZOMBIE_STACKS env variable.
 *
 * @param rpcs          RPC server
 */
extern void sockts_kill_zombie_stacks_if_many(rcf_rpc_server *rpcs);

/**
 * Update ARP table to set fake or actual MAC address
 * 
 * @param rpcs_src          Source RPC server
 * @param iface_src         Source interface
 * @param rpcs_dest         Destination RPC server
 * @param iface_dest        Destination interface
 * @param addr_dest         Destination address
 * @param link_addr_dest    New destination MAC or @c NULL
 * @param is_static         If the new ARP row should be static
 */
extern void update_arp(rcf_rpc_server *rpcs_src,
                       const struct if_nameindex *iface_src,
                       rcf_rpc_server *rpcs_dest,
                       const struct if_nameindex *iface_dest,
                       const struct sockaddr *addr_dest,
                       const struct sockaddr *link_addr_dest,
                       te_bool is_static);

/**
 * Close array of sockets
 * 
 * @param rpcs  RPC server
 * @param s     Sockets array
 * @param num   Sockets number
 */
extern void sockts_close_sockets(rcf_rpc_server *rpcs, int *s, int num);

/**
 * Initialize mmsghdr structure.
 * 
 * @param num    Messages number
 * @param length Payload buffer length
 * @param mmsg   Messages array
 */
extern void init_mmsghdr(int num, int length, struct rpc_mmsghdr **mmsg);

/**
 * Clean messages array.
 * 
 * @param mmsg   Messages array
 * @param num    Messages number
 */
extern void cleanup_mmsghdr(struct rpc_mmsghdr *mmsg, int num);

/**
 * Clean and free sockets array.
 * 
 * @param rcps  RPC server handler
 * @param sock  Sockets array
 * @param num   Sockets number
 */
static inline void
clean_sockets(rcf_rpc_server *rpcs, int *sock, int num)
{
    int result;
    int i;
    UNUSED(result);

    if (sock == NULL)
        return;

    for (i = 0; i < num; i++)
        CLEANUP_RPC_CLOSE(rpcs, sock[i]);
    free(sock);
}

/**
 * Check if operation is done.
 * 
 * @param rpcs  RPC server haandler
 * 
 * @return @c TRUE if the operation is done.
 */
static inline te_bool
sockts_is_op_done(rcf_rpc_server *rpcs)
{
    te_bool done;

    if (rpcs->op != RCF_RPC_WAIT)
        return TRUE;

    CHECK_RC(rcf_rpc_server_is_op_done(rpcs, &done));

    return done;
}

/**
 * Check if a RPC call is blocked.
 *
 * @param _rpcs         RPC server handle.
 * @param _func_name    Called function name or verdict beginning.
 */
#define SOCKTS_CALL_IS_BLOCKED(_rpcs, _func_name) \
    do {                                                            \
        if (sockts_is_op_done(_rpcs))                               \
            TEST_VERDICT("%s call is not blocked", _func_name);     \
    } while (0)

/**
 * Send data flow from @p rpcs1 to @p rpcs2 to extend congestion and send
 * TCP windows.
 *
 * @param rpcs1         First RPC server
 * @param s1            Transmitting socket
 * @param rpcs2         Second RPC server
 * @param s2            Receiving socket
 * @param req_window    Minimum required TCP send window size or @c 0 get
 *                      maximum possible size
 *
 * @note The function jumps to cleanup in case of failure.
 */
extern void sockts_extend_cong_window_req(rcf_rpc_server *rpcs1, int s1,
                                          rcf_rpc_server *rpcs2, int s2,
                                          unsigned int req_window);

/**
 * sockts_extend_cong_window_req() with @p req_wind=0
 */
static inline void
sockts_extend_cong_window(rcf_rpc_server *rpcs1, int s1,
                          rcf_rpc_server *rpcs2, int s2)
{
    sockts_extend_cong_window_req(rpcs1, s1, rpcs2, s2, 0);
}


/**
 * Close a socket in one of ways from @b closing_way list. Note, this
 * function does not support non-blocking call.
 * 
 * @param rpcs      RPC server handler
 * @param parent    Parent RPC server or @c NULL
 * @param sock      Socket
 * @param way       How to close
 */
extern void sockts_close(rcf_rpc_server *rpcs, rcf_rpc_server *parent,
                         int *sock, closing_way way);

/**
 * Release msghdr structure.
 * 
 * @param msg   The structure location
 */
static inline void
sockts_release_msghdr(rpc_msghdr *msg)
{
    if (msg == NULL)
        return;

    free(msg->msg_control);
    if (msg->msg_iov != NULL)
        free(msg->msg_iov->iov_base);
    free(msg->msg_iov);
}

/**
 * Initialize msghdr structure with allocation required buffers.
 * 
 * @param msg       The structure location
 * @param length    Payload buffer length
 */
static inline void
sockts_init_msghdr(rpc_msghdr *msg, int length)
{
    struct rpc_iovec *vector;

    memset(msg, 0, sizeof(*msg));

    if (length == 0)
    {
        msg->msg_iov = NULL;
        msg->msg_iovlen = msg->msg_riovlen = 0;
    }
    else
    {
        vector = te_calloc_fill(1, sizeof(*vector), 0);
        vector->iov_base = te_make_buf_by_len(length);
        vector->iov_len = vector->iov_rlen = length;

        msg->msg_iovlen = msg->msg_riovlen = 1;
        msg->msg_iov = vector;
    }

    msg->msg_control = te_calloc_fill(1, SOCKTS_CMSG_LEN, 0);
    msg->msg_controllen = SOCKTS_CMSG_LEN;
    msg->msg_cmsghdr_num = 1;
    msg->msg_flags = 0;
    msg->msg_name = NULL;
    msg->msg_namelen = msg->msg_rnamelen = 0;
}

/**
 * Re-create Onload stack if env @b EF_NAME is set.
 * 
 * @note The function is inteded for use only in prologues/epilouges, as some
 * packages require changing EF_ variables. Affected packages: reuseport, bpf,
 * timestamps and multicast.
 *
 * @param pco_iut   IUT RPC server
 */
extern void sockts_recreate_onload_stack(rcf_rpc_server *pco_iut);

/**
 * Kill zombie stacks and report the error on failure.
 * 
 * @param pco_iut   IUT RPC server
 * @param reboot    Whether to reboot @p pco_reuse_stack RPC server
 */
extern void sockts_kill_check_zombie_stack(rcf_rpc_server *rpcs,
                                           te_bool reboot);

/**
 * Check msg_flags value and report verdict in case of failure.
 *
 * @param msg       msghdr structure to be checked
 * @param exp_flags Expected flags value
 */
static inline void
sockts_check_msg_flags(rpc_msghdr *msg, rpc_send_recv_flags exp_flags)
{
    if (msg->msg_flags != exp_flags)
    {
        TEST_VERDICT("Unexpected msg_flags: %s instead of %s",
                     send_recv_flags_rpc2str(msg->msg_flags),
                     send_recv_flags_rpc2str(exp_flags));
    }
}

/**
 * Check if ZF shim testing is run.
 *
 * @return @c TRUE if it is.
 */
extern te_bool sockts_zf_shim_run(void);


/**
 * Get @b zf_stackdump binary path on the agent.
 *
 * @param rpcs  RPC server handle
 *
 * @return The binary location string, free the returned value when it is
 *         not required anymore.
 */
extern char * sockts_zf_stackdump_path(rcf_rpc_server *rpcs);

/**
 * Call specified socket creation function.
 *
 * @param sock_func   Socket creation function.
 * @param rpcs        RPC server handle.
 * @param domain      Communication domain.
 * @param type        Socket type.
 * @param protocol    Protocol.
 *
 * @return Socket descriptor on success, -1 on failure.
 */
extern int sockts_socket(sockts_socket_func sock_func,
                         rcf_rpc_server *rpcs,
                         rpc_socket_domain domain,
                         rpc_socket_type type,
                         rpc_socket_proto protocol);

/**
 * Set random IPv4 multicast address to @p addr.
 */
extern void sockts_set_multicast_addr(struct sockaddr *addr);

/**
 * Check if a network interface is @b sfc interface or not.
 *
 * @param ta        Test agent name
 * @param ifname    Interface name
 * @param sfc       Return @c TRUE if it is SFC interface
 *
 * @return Status code
 */
extern te_errno sockts_interface_is_sfc(const char *ta, const char *ifname,
                                        te_bool *sfc);

/**
 * Substitute SO_SNDBUFFORCE/SO_RCVBUFFORCE with
 * SO_SNDBUF/SO_RCVBUF for getsockopt(). Other options
 * are not changed.
 *
 * @param opt       Socket option.
 *
 * @return Socket option (substituted if necessary).
 */
static inline int
sockts_fix_get_opt(int opt)
{
    if (opt == RPC_SO_SNDBUFFORCE)
        return RPC_SO_SNDBUF;
    else if (opt == RPC_SO_RCVBUFFORCE)
        return RPC_SO_RCVBUF;

    return opt;
}

/**
 * Get value of a resource limit, check if it is less than
 * desired, and if so, increase it.
 *
 * @param rpcs          RPC server handle.
 * @param resource      Resource number.
 * @param lim           Desired value.
 */
extern void
sockts_inc_rlimit(rcf_rpc_server *rpcs, int resource, size_t lim);

/**
 * Get timestamp (in microseconds) from a packet captured by CSAP.
 *
 * @param pkt     Packet captured by CSAP.
 * @param tv      Where to save obtained timestamp.
 *
 * @return Status code.
 */
extern te_errno sockts_get_csap_pkt_ts(asn_value *pkt, struct timeval *tv);

/**
 * Set interfaces down/up, wait for them to become ready again.
 *
 * @param rpcs1     The first RPC server handle.
 * @param intf1     The first interface.
 * @param ...       Sequence of [rpcsN, intfN], the last argument
 *                  should be @c NULL.
 *
 * @return Status code.
 */
extern te_errno sockts_ifs_down_up(rcf_rpc_server *rpcs1,
                                   const struct if_nameindex *intf1, ...);

/**
 * Try to restart all the interfaces mentioned in the environment.
 *
 * @note Interfaces will not be restarted if no RPC server is
 *       specified for a host.
 *
 * @param env           Pointer to environment variable.
 *
 * @return Status code.
 */
extern te_errno sockts_restart_all_env_ifs(tapi_env *env);

/**
 * Get TCP addresses/ports from packet described in ASN.
 *
 * @param pkt       Packet description.
 * @param src       Where to save source address.
 * @param dst       Where to save destination address.
 *
 * @return Status code.
 */
extern te_errno sockts_get_addrs_from_tcp_asn(asn_value *pkt,
                                              struct sockaddr_storage *src,
                                              struct sockaddr_storage *dst);

/**
 * Make remote address for @b connect() and other functions in case of IPv6
 * link local addresses. Note, that this function simply copies
 * @p remote_addr to @p conn_addr when address is not IPv6 link local.
 *
 * @param remote_addr Peer host address
 * @param local_addr  Local host address
 * @param conn_addr   Address that can be used in @b connect() fucntion,
 *                    in case of IPv6 link local address
 */
static inline void
sockts_ip6_get_ll_remote_addr(const struct sockaddr *remote_addr,
                              const struct sockaddr *local_addr,
                              struct sockaddr_storage *conn_addr)
{
    tapi_sockaddr_clone_exact(remote_addr, conn_addr);
    if (remote_addr->sa_family == AF_INET6 &&
        IN6_IS_ADDR_LINKLOCAL(&SIN6(remote_addr)->sin6_addr))
        SIN6(conn_addr)->sin6_scope_id =
            SIN6(local_addr)->sin6_scope_id;
}

/**
 * Check whether IP6 address is link local or not.
 *
 * @param addr Address to be checked
 *
 * @return Return @c TRUE if @p addr is link local IP6 address or @c FALSE
 *         otherwise
 */
static inline te_bool
sockts_is_addr_ip6_linklocal(const struct sockaddr *addr)
{
    if (addr->sa_family == AF_INET6 &&
        IN6_IS_ADDR_LINKLOCAL(&SIN6(addr)->sin6_addr))
        return TRUE;
    return FALSE;
}

/**
 * Return string containing a given string + ": ", unless
 * a given string is empty.
 *
 * @param str       String to use in a prefix.
 *
 * @return @p str + ": " if @p str is not empty;
 *         empty string otherwise.
 */
static inline const char *
sockts_prefix(const char *str)
{
    static char buf[2048] = "";

    if (str == NULL || *str == '\0')
        return "";

    TE_SPRINTF(buf, "%s: ", str);
    return buf;
}

/**
 * Capture packets by CSAP, check whether a given field in their headers
 * has expected value.
 *
 * @param pco               RPC server.
 * @param field_name        Name of the checked field (to be printed in
 *                          verdicts).
 * @param field_labels      ASN labels of the checked field.
 * @param exp_value_name    Name of the expected value (to be printed
 *                          in verdicts).
 * @param exp_value         Expected value of the field. If negative
 *                          (use @c SOCKTS_SEND_CHECK_FIELD_SAME_NONZERO),
 *                          it is checked that the field has the same
 *                          (arbitrary) non-zero value in all packets.
 * @param wrong_value_name  Name of the known "wrong value" (to be printed
 *                          in verdicts).
 * @param wrong_value       Known "wrong value" of the field (which should
 *                          not be encountered); ignored if not positive.
 * @param csap              CSAP on Tester.
 * @param failed            Will be set to @c TRUE if a problem was
 *                          encountered when processing captured
 *                          packets.
 * @param err_msg           Message to print at the beginning of
 *                          verdicts.
 */
extern void sockts_check_field(rcf_rpc_server *pco,
                               const char *field_name,
                               const char *field_labels,
                               const char *exp_value_name,
                               long int exp_value,
                               const char *wrong_value_name,
                               long int wrong_value,
                               csap_handle_t csap,
                               te_bool *failed,
                               const char *err_msg);

/**
 * Send data from IUT socket, receive it on its peer. Capture sent
 * packets by CSAP, check whether a given field in their headers
 * has expected value.
 *
 * @param pco_iut           RPC server on IUT.
 * @param iut_s             Socket on IUT.
 * @param pco_tst           RPC server on Tester.
 * @param tst_s             Socket on Tester.
 * @param sock_type         IUT socket type.
 * @param tst_addr          Address/port to which the Tester socket is
 *                          bound.
 * @param field_name        Name of the checked field (to be printed in
 *                          verdicts).
 * @param field_labels      ASN labels of the checked field.
 * @param exp_value_name    Name of the expected value (to be printed
 *                          in verdicts).
 * @param exp_value         Expected value of the field. If negative
 *                          (use @c SOCKTS_SEND_CHECK_FIELD_SAME_NONZERO),
 *                          it is checked that the field has the same
 *                          (arbitrary) non-zero value in all packets.
 * @param wrong_value_name  Name of the known "wrong value" (to be printed
 *                          in verdicts).
 * @param wrong_value       Known "wrong value" of the field (which should
 *                          not be encountered); ignored if not positive.
 * @param csap              CSAP on Tester.
 * @param failed            Will be set to @c TRUE if a problem was
 *                          encountered when processing captured
 *                          packets.
 * @param err_msg           Message to print at the beginning of
 *                          verdicts.
 */
extern void sockts_send_check_field(rcf_rpc_server *pco_iut, int iut_s,
                                    rcf_rpc_server *pco_tst, int tst_s,
                                    sockts_socket_type sock_type,
                                    const struct sockaddr *tst_addr,
                                    const char *field_name,
                                    const char *field_labels,
                                    const char *exp_value_name,
                                    long int exp_value,
                                    const char *wrong_value_name,
                                    long int wrong_value,
                                    csap_handle_t csap,
                                    te_bool *failed,
                                    const char *err_msg);

/**
 * Pass this to sockts_send_check_field() as expected value
 * to check that all packets have the same non-zero value
 * in the checked field.
 */
#define SOCKTS_SEND_CHECK_FIELD_SAME_NONZERO -1

/**
 * Get all network addresses from a given interface which match
 * specified network.
 *
 * @param rpcs            RPC server.
 * @param if_name         Interface name.
 * @param net             Network to which addresses should belong.
 * @param af              Address family.
 * @param addrs_out       Where to save obtained addresses.
 * @param addrs_num_out   Where to save number of obtained addresses.
 *
 * @return Status code.
 */
extern te_errno sockts_get_net_addrs_from_if(rcf_rpc_server *rpcs,
                                             const char *if_name,
                                             tapi_env_net *net, int af,
                                             struct sockaddr_storage **addrs_out,
                                             unsigned int *addrs_num_out);

/** Sending functions */
typedef enum {
    SOCKTS_SENDF_WRITE = TARPC_SEND_FUNC_WRITE,         /**< write() */
    SOCKTS_SENDF_WRITEV = TARPC_SEND_FUNC_WRITEV,       /**< writev() */
    SOCKTS_SENDF_SEND = TARPC_SEND_FUNC_SEND,           /**< send() */
    SOCKTS_SENDF_SENDTO = TARPC_SEND_FUNC_SENDTO,       /**< sendto() */
    SOCKTS_SENDF_SENDMSG = TARPC_SEND_FUNC_SENDMSG,     /**< sendmsg() */
    SOCKTS_SENDF_SENDMMSG = TARPC_SEND_FUNC_SENDMMSG,   /**< sendmmsg() */
    SOCKTS_SENDF_ONLOAD_ZC_SEND,          /**< onload_zc_send() */
    SOCKTS_SENDF_ONLOAD_ZC_SEND_USER_BUF, /**< onload_zc_send_user_buf() */
    SOCKTS_SENDF_TEMPLATE_SEND, /**< template_send() */
    SOCKTS_SENDF_OD_SEND, /**< od_send() */
    SOCKTS_SENDF_OD_SEND_RAW, /**< od_send_raw() */
} sockts_send_func;

/** List of sending functions for TEST_GET_ENUM_PARAM() */
#define SOCKTS_SENDF_LIST \
    { "write", SOCKTS_SENDF_WRITE },                          \
    { "writev", SOCKTS_SENDF_WRITEV },                        \
    { "send", SOCKTS_SENDF_SEND },                            \
    { "sendto", SOCKTS_SENDF_SENDTO },                        \
    { "sendmsg", SOCKTS_SENDF_SENDMSG },                      \
    { "sendmmsg", SOCKTS_SENDF_SENDMMSG },                    \
    { "onload_zc_send", SOCKTS_SENDF_ONLOAD_ZC_SEND },        \
    { "onload_zc_send_user_buf",                              \
      SOCKTS_SENDF_ONLOAD_ZC_SEND_USER_BUF },                 \
    { "template_send", SOCKTS_SENDF_TEMPLATE_SEND },          \
    { "od_send", SOCKTS_SENDF_OD_SEND },                      \
    { "od_send_raw", SOCKTS_SENDF_OD_SEND_RAW }

/**
 * Get sending function ID (see sockts_send_func enum).
 *
 * @param _var_name     Test parameter name.
 */
#define SOCKTS_GET_SEND_FUNC_ID(_var_name) \
    TEST_GET_ENUM_PARAM(_var_name, SOCKTS_SENDF_LIST)

/** Receiving functions */
typedef enum {
    SOCKTS_RECVF_READ,                     /**< read() */
    SOCKTS_RECVF_READV,                    /**< readv() */
    SOCKTS_RECVF_RECV,                     /**< recv() */
    SOCKTS_RECVF_RECVFROM,                 /**< recvfrom() */
    SOCKTS_RECVF_RECVMSG,                  /**< recvmsg() */
    SOCKTS_RECVF_RECVMMSG,                 /**< recvmmsg() */
    SOCKTS_RECVF_ONLOAD_ZC_RECV,           /**< onload_zc_recv() */
    SOCKTS_RECVF_ONLOAD_ZC_HLRX_RECV_ZC,   /**< onload_zc_hlrx_recv_zc() */
    SOCKTS_RECVF_ONLOAD_ZC_HLRX_RECV_COPY, /**< onload_zc_hlrx_recv_copy() */
} sockts_recv_func;

/** List of receiving functions for TEST_GET_ENUM_PARAM() */
#define SOCKTS_RECVF_LIST \
    { "read", SOCKTS_RECVF_READ },                                        \
    { "readv", SOCKTS_RECVF_READV },                                      \
    { "recv", SOCKTS_RECVF_RECV },                                        \
    { "recvfrom", SOCKTS_RECVF_RECVFROM },                                \
    { "recvmsg", SOCKTS_RECVF_RECVMSG },                                  \
    { "recvmmsg", SOCKTS_RECVF_RECVMMSG },                                \
    { "onload_zc_recv", SOCKTS_RECVF_ONLOAD_ZC_RECV },                    \
    { "onload_zc_hlrx_recv_zc", SOCKTS_RECVF_ONLOAD_ZC_HLRX_RECV_ZC },    \
    { "onload_zc_hlrx_recv_copy", SOCKTS_RECVF_ONLOAD_ZC_HLRX_RECV_COPY }

/**
 * Get receiving function ID (see sockts_recv_func enum).
 *
 * @param _var_name     Test parameter name.
 */
#define SOCKTS_GET_RECV_FUNC_ID(_var_name) \
    TEST_GET_ENUM_PARAM(_var_name, SOCKTS_RECVF_LIST)

/**
 * Get an integer value of an option in /proc/sys/net/ipv4 tree.
 *
 * @param[in]  ta        Agent name.
 * @param[in]  option    Option name.
 * @param[out] val       Where to save the value.
 *
 * @return Status code.
 */
static inline te_errno
sockts_cfg_sys_ipv4_get_int(const char *ta, const char *option, int *val)
{
    return tapi_cfg_sys_ns_get_int(ta, val, "net/ipv4/%s", option);
}

/**
 * Set an integer value of an option in /proc/sys/net/ipv4 tree.
 * The function checks the existing value and rewrite it if needed.
 *
 * @param[in]  ta        Agent name.
 * @param[in]  option    Option name.
 * @param[in]  val       Value to set.
 * @param[out] changed   Flag, is set to @c TRUE if the option value was
 *                       changed, otherwise old flag value is kept.
 *                       May be @c NULL.
 *
 * @return Status code.
 */
static inline te_errno
sockts_cfg_sys_ipv4_set_int(const char *ta, const char *option, int val,
                            te_bool *changed)
{
    int old_val;
    int rc;

    if ((rc = sockts_cfg_sys_ipv4_get_int(ta, option, &old_val)) != 0)
        return rc;

    if (val != old_val)
    {
        rc = tapi_cfg_sys_ns_set_int(ta, val, NULL, "net/ipv4/%s", option);
        if (rc == 0 && changed != NULL)
            *changed = TRUE;
    }

    return rc;
}

/**
 * Initialize arguments for rpc_pattern_sender() and
 * rpc_pattern_receiver() to run them together on both
 * ends of the connection.
 *
 * @param send_ctx        Arguments for rpc_pattern_sender().
 * @param recv_ctx        Arguments for rpc_pattern_receiver().
 * @param min_pkt_len     Minimum sent packet length.
 * @param max_pkt_len     Maximum sent packet length.
 * @param transmit_time   How long to transmit data (in seconds).
 * @param receive_time    How long to receive data (in seconds).
 * @param time2wait       Maximum time to wait for writability or
 *                        readability (in milliseconds).
 */
extern void sockts_init_pat_sender_receiver(tapi_pat_sender *send_ctx,
                                            tapi_pat_receiver *recv_ctx,
                                            int min_pkt_len,
                                            int max_pkt_len,
                                            int transmit_time,
                                            int receive_time,
                                            unsigned int time2wait);

/**
 * Perform sendmsg() with cmsg structure if @p with_cmsg is @c TRUE
 *
 * @param pco               RPC server.
 * @param socket            Socket on sender side.
 * @param addr              Address/port to which the receiver socket is
 *                          bound.
 * @param with_cmsg         Is it needed to specify cmsg header.
 * @param cmsg_level        Originating protocol.
 * @param cmsg_type         Protocol specific type.
 * @param data              Ancillary data.
 * @param buffer            Data to send.
 * @param buflen            Number of bytes to send.
 *
 * @return Number of bytes sent or -1 in case of failure.
 */
extern ssize_t sockts_sendmsg_with_cmsg(rcf_rpc_server *pco,
                                        int socket,
                                        const struct sockaddr *addr,
                                        te_bool with_cmsg,
                                        int cmsg_level,
                                        int cmsg_type,
                                        int data,
                                        void *buffer,
                                        ssize_t buflen);

/**
 * Send data with sendmsg(), passing cmsg if required.
 * Receive and check data on peer.
 * If @p csap is not @c CSAP_INVALID_HANDLE, check that
 * in all received packets specified field has expected value.
 *
 * @param pco_sender              RPC server from which to send data.
 * @param pco_receiver            RPC server where to receive data.
 * @param sender_s                Socket on sender.
 * @param receiver_s              Socket on receiver.
 * @param receiver_addr           Address/port to which the receiver socket is
 *                                bound.
 * @param csap                    CSAP on receiver.
 * @param field_name              Name of the checked field (to be printed in
 *                                verdicts).
 * @param field_labels            ASN labels of the checked field.
 * @param exp_value_name          Name of the expected value (to be printed
 *                                in verdicts).
 * @param expected_field_value    Expected value of the field.
 * @param unexp_value_name        Name of the known "wrong value" (to be printed
 *                                in verdicts).
 * @param unexpected_field_value  Known "wrong value" of the field (which should
 *                                not be encountered); ignored if not positive.
 * @param with_cmsg               Is it needed to specify cmsg header.
 * @param cmsg_level              Originating protocol (for CMSG).
 * @param cmsg_type               Protocol specific type (for CMSG).
 * @param data                    Ancillary data (for CMSG).
 * @param test_failed             Will be set to @c TRUE if a problem was
 *                                encountered when processing captured
 *                                packets.
 * @param err_msg                 Message to print at the beginning of
 *                                verdicts.
 */
extern void sockts_send_check_field_cmsg(rcf_rpc_server *pco_sender,
                                         rcf_rpc_server *pco_receiver,
                                         int sender_s, int receiver_s,
                                         const struct sockaddr *receiver_addr,
                                         csap_handle_t csap,
                                         const char *field_name,
                                         const char *field_labels,
                                         const char *exp_value_name,
                                         int expected_field_value,
                                         const char *unexp_value_name,
                                         int unexpected_field_value,
                                         te_bool with_cmsg,
                                         int cmsg_level,
                                         int cmsg_type,
                                         int data,
                                         te_bool *test_failed,
                                         const char *err_msg);

/**
 * Check whether a given interface belongs to IUT network in environment.
 *
 * @param env     Pointer to test environment.
 * @param name    Name of the interface in the environment (not its system
 *                name on the tested host).
 *
 * @return @c TRUE if the interface belongs to IUT network, @c FALSE
 *         otherwise.
 */
extern te_bool sockts_iface_is_iut(tapi_env *env, const char *name);

/**
 * Change RPC server user to @c SOCKTS_DEF_UID
 *
 * @return @c 0 on success, @c -1 otherwise
 */
static inline int
sockts_server_change_uid(rcf_rpc_server *rpcs)
{
    tarpc_uid_t     uid = 0;

    CHECK_RC(tapi_cfg_add_user_if_needed(rpcs->ta, SOCKTS_DEF_UID, NULL));
    rpc_setuid(rpcs, SOCKTS_DEF_UID);
    uid = rpc_getuid(rpcs);
    if (uid != SOCKTS_DEF_UID)
    {
        ERROR("User ID change failed");
        return -1;
    }
    return 0;
}

/**
 * Clear the list of all current possible memory leaks.
 * Can only be used on kernels with CONFIG_DEBUG_KMEMLEAK support.
 *
 * @param ta    Agent name to spawn RPC server (should not be run
 *              in network namespace)
 */
extern void sockts_kmemleak_clear(const char *ta);

/**
 * Print report from Kernel Memory Leak Detector.
 * Can only be used on kernels with CONFIG_DEBUG_KMEMLEAK support.
 *
 * @param ta    Agent name to spawn RPC server (should not be run
 *              in network namespace)
 */
extern void sockts_kmemleak_get_report(const char *ta);

/**
 * Determine if it is needed to find parent agent and interface
 *
 * @return    @c TRUE if netns used with vlan/macvlan/ipvlan or bond/team
 *            @c FALSE if only netns used or netns not used
 */
static inline te_bool
sockts_not_pure_netns_used()
{
    return getenv("SOCKAPI_TS_NETNS") != NULL &&
           (getenv("TE_IUT_TST1_MV") != NULL ||
           getenv("TE_IUT_TST1_VLAN") != NULL ||
           getenv("SOCKAPI_TS_BOND_NAME") != NULL ||
           getenv("SOCKAPI_TS_IPVLAN_ENV") != NULL);
}

/**
 * Find parent interface and agent for NETNS interface
 *
 * @param[in] rpcs            RPC server handle
 * @param[in] ifname          Interface name
 * @param[out] agent_parent   Parent agent name
 * @param[out] ifname_parent  Parent interface name
 *
 * @return Status code
 */
extern te_errno
sockts_find_parent_netns(rcf_rpc_server *rpcs,
                         const char *ifname,
                         char *agent_parent,
                         char *ifname_parent);

/**
 * Free used_agt_name and used_interface_name variables
 */
extern void
sockts_free_used_params_name();

/**
 * Getter for used_agt_name
 *
 * @param rpcs                RPC server handle
 * @param ifname              Interface name
 */
extern char*
sockts_get_used_agt_name(rcf_rpc_server *rpcs,
                         const char *ifname);

/**
 * Getter for used_interface_name
 *
 * @param rpcs                RPC server handle
 * @param ifname              Interface name
 */
extern char*
sockts_get_used_if_name(rcf_rpc_server *rpcs,
                        const char *ifname);

/**
 * Find parent physical interfaces.
 *
 * @param rpcs              RPC server handle
 * @param ifname            Interface name
 * @param[out] ifaces       List of interfaces
 */
extern void sockts_find_parent_if(rcf_rpc_server *rpcs,
                                  const char *ifname,
                                  tqh_strings *ifaces);

/**
 * Add namespace on @p host and @p recv_veth2_name interface to it.
 * If @p ns_addr is not @c NULL and it doesn't point to @c NULL, use this
 * address; otherwise, allocate an IP address from @p net_handle. Add the
 * address to the interface.
 * Start test agent and RPC server in namespace.
 *
 * @param ta_name               Test agent name.
 * @param host                  Host name.
 * @param ta_type               Test agent type.
 * @param ta_rpcprovider        RPC provider.
 * @param net_handle            Network handle (network addresses pool).
 * @param recv_veth2_name       Name of the interface to pass to namespace.
 * @param netns                 Name of the created namespace.
 * @param netns_ta              Name of the created Test Agent.
 * @param netns_rpcs            Name of the created RPC server.
 * @param rcf_port              Port number.
 * @param rpcs_ns               Location for netns RPC server or @c NULL.
 * @param ns_addr               Location for allocated address.
 * @param addr_handle           Location for allocated address configuration
 *                              handle.
 *
 * @note The function jumps to cleanup in case of failure.
 */
extern void
sockts_netns_setup_common(const char *ta_name, const char *host,
                          const char *ta_type, const char *ta_rpcprovider,
                          cfg_handle net_handle,
                          const char *recv_veth2_name, const char *netns,
                          const char *netns_ta, const char *netns_rpcs,
                          uint16_t rcf_port, rcf_rpc_server **rpcs_ns,
                          struct sockaddr **ns_addr,
                          cfg_handle *addr_handle);


/**
 * Add namespace on IUT host and @p recv_veth2_name interface to it.
 * Allocate IP address from @p net_handle and add it to interface.
 * Start test agent and RPC server in namespace.
 *
 * @param pco_iut               RPC server in the original namespace.
 * @param net_handle            Network handle (network addresses pool).
 * @param recv_veth2_name       Name of the interface to pass to namespace.
 * @param netns                 Name of the created namespace.
 * @param netns_ta              Name of the created Test Agent.
 * @param netns_rpcs            Name of the created RPC server.
 * @param rpcs_ns               Location for netns RPC server.
 * @param ns_addr               Location for allocated address.
 * @param addr_handle           Location for allocated address configuration
 *                              handle.
 *
 * @note The function jumps to cleanup in case of failure.
 */
extern void
sockts_iut_netns_setup(rcf_rpc_server *pco_iut, cfg_handle net_handle,
                       const char *recv_veth2_name, const char *netns,
                       const char *netns_ta, const char *netns_rpcs,
                       rcf_rpc_server **rpcs_ns, struct sockaddr **ns_addr,
                       cfg_handle *addr_handle);

/**
 * Destroy the created network namespace together with TA and RPC server
 * created in it.
 *
 * @param ta          Test agent on IUT.
 * @param rpcs_ns     RPC server in the created namespace.
 * @param netns       Name of the namespace.
 * @param netns_ta    Name of the Test Agent.
 *
 * @note The function jumps to cleanup in case of failure.
 */
extern void
sockts_destroy_netns(const char *ta, rcf_rpc_server *rpcs_ns,
                     const char *netns, const char *netns_ta);

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif /* !__TS_SOCKAPI_TS_H__ */

