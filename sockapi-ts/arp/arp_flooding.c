/* SPDX-License-Identifier: Apache-2.0 */
/* (c) Copyright 2004 - 2022 Xilinx, Inc. All rights reserved. */
/*
 * Socket API Test Suite
 * ARP table
 *
 * $Id$
 */

/** @page arp-arp_flooding ARP table flooding
 *
 * @objective ARP table is flooded
 *
 * @type conformance
 *
 * @reference @ref COMER, chapter 5
 *
 * @param pco_iut           PCO on IUT
 * @param pco_tst           PCO on TESTER
 * @param iut_addr          Network address on IUT
 * @param tst_addr          Network address on Tester
 * @param iut_lladdr        Ethernet address on IUT
 * @param tst_lladdr        Ethernet address on Tester
 * @param iut_if            Network interface on IUT
 * @param tst_if            Network interface on Tester
 * @param net               Network to which host addresses belong
 * @param is_unicast        @c TRUE if arp requests generated by
 *                          @b arp_packets_sender are unicast,
 *                          @c FALSE otherwise.
 *                          This parameter is considered only when
 *                          @p num_of_requests is not zero.
 * @param num_of_replies    Number of arp replies which
 *                          @b arp_packets_sender should generate
 * @param num_of_requests   Number of arp requests which
 *                          @b arp_packets_sender should generate
 *
 * @par Test sequence:
 * -# If there is @p tst_addr ARP entry on IUT,
 *    delete it;
 * -# Create @p request_list: create @p num_of_requests IP addresses
 *    mapped on MAC addresses. Addresses should be from the IP network
 *    @p net. These mappings should be used in ARP requests
 *    generated on @p pco_tst;
 * -# Create @p reply_list: create @p num_of_replies IP addresses
 *    mapped on MAC addresses. Addresses should be from the IP network
 *    @p net. These mappings should be used in ARP replies
 *    generated on @p pco_tst;
 * -# Create and launch @p num_of_request_sender on @p pco_tst,
 *    which generates and sends @p num_of_requests ARP requests
 *    to IUT using @p request_list protocol and hardware addresses
 *    as sender protocol and hardware addresses, and using
 *    IUT hardware address as target hardware address if
 *    @p is_unicast is @c TRUE, otherwise using broadcast hardware address
 *    as target hardware address.
 * -# Create and launch @p reply_sender on @p pco_tst,
 *    which generates and sends @p num_of_replies ARP replies
 *    to IUT using @p reply_list protocol and hardware addresses
 *    as sender protocol and hardware addresses.
 * -# Generate and send valid ARP request from Tester asking for IUT;
 * -# Launch Ethernet sniffer looking for ARP request from IUT
 *    asking for Tester address;
 * -# Initiate TCP connection between @p pco_iut and @p pco_tst,
 *    using @p pco_iut as client, check that connection succeed;
 * -# Stop Ethernet sniffer, check that no ARP request was caught.
 *
 * @author Renata Sayakhova <Renata.Sayakhova@oktetlabs.ru>
 */

#define TE_TEST_NAME    "arp/arp_flooding"

#include <errno.h>
#include <pthread.h>

#include "sockapi-test.h"
#include "rcf_api.h"
#include "arp_test_macros.h"
#include "arp_send_recv.h"

int
main(int argc, char *argv[])
{
    tapi_env_net   *net     = NULL;
    rcf_rpc_server *pco_iut = NULL;
    rcf_rpc_server *pco_tst = NULL;

    const struct sockaddr  *iut_addr = NULL;
    const struct sockaddr  *tst_addr = NULL;
    const struct sockaddr  *iut_lladdr = NULL;
    const struct sockaddr  *tst_lladdr = NULL;

    const struct if_nameindex  *iut_if = NULL;
    const struct if_nameindex  *tst_if = NULL;

    pthread_t                 request_sender;
    struct arp_sender_args    request_sender_args;
    int                       request_sender_rc;

    pthread_t                 reply_sender;
    struct arp_sender_args    reply_sender_args;
    int                       reply_sender_rc;

    proto2hw_addr_map        *fake_addr_list = NULL;
    proto2hw_addr_map        *request_list = NULL;
    proto2hw_addr_map        *reply_list = NULL;

    te_bool                   is_unicast;
    int                       num_of_requests;
    int                       num_of_replies;
    int                       num_of_pkts;
    unsigned int              frames_caught;

    const uint8_t            *tgt_hwaddr = NULL;
    csap_handle_t             handle = CSAP_INVALID_HANDLE;

    /* Preambule */
    TEST_START;

    TEST_GET_PCO(pco_iut);
    TEST_GET_PCO(pco_tst);

    TEST_GET_NET(net);
    TEST_GET_ADDR(pco_iut, iut_addr);
    TEST_GET_ADDR(pco_tst, tst_addr);

    TEST_GET_LINK_ADDR(iut_lladdr);
    TEST_GET_LINK_ADDR(tst_lladdr);

    TEST_GET_IF(iut_if);
    TEST_GET_IF(tst_if);

    TEST_GET_INT_PARAM(num_of_requests);
    TEST_GET_INT_PARAM(num_of_replies);
    TEST_GET_BOOL_PARAM(is_unicast);

    num_of_pkts = num_of_requests + num_of_replies;

    CHECK_RC(tapi_cfg_del_neigh_entry(pco_iut->ta, iut_if->if_name,
                                      tst_addr));

    CFG_WAIT_CHANGES;

    /* Generate list of clients addresses */
    GENERATE_MAP_LIST(net, num_of_pkts, fake_addr_list, FALSE, FALSE);

    if (num_of_pkts < num_of_requests + num_of_replies)
    {
        num_of_requests = num_of_pkts / 2;
        num_of_replies = num_of_pkts - num_of_requests;
    }
    request_list = fake_addr_list;
    reply_list = fake_addr_list + num_of_requests;

    tgt_hwaddr = (is_unicast == TRUE) ? (uint8_t *)iut_lladdr->sa_data :
                                        mac_broadcast;

    FILL_ARP_SENDER_ARGS(&request_sender_args,
                         pco_tst->ta, tst_if->if_name,
                         NULL, NULL,
                         ARPOP_REQUEST,
                         NULL, NULL,
                         CVT_PROTO_ADDR(iut_addr),
                         tgt_hwaddr,
                         num_of_requests,
                         request_list);
    FILL_ARP_SENDER_ARGS(&reply_sender_args,
                         pco_tst->ta, tst_if->if_name,
                         NULL, NULL,
                         ARPOP_REPLY,
                         NULL, NULL,
                         CVT_PROTO_ADDR(iut_addr),
                         CVT_HW_ADDR(iut_lladdr),
                         num_of_replies,
                         reply_list);

   /* Create and launch ARP request sender */
    if (pthread_create(&request_sender, NULL,
                       launch_arp_sender,
                       (void *)&request_sender_args) < 0)
    {
        rc = errno;
        TEST_FAIL("%d: Failed to create request sender",
                  __LINE__);
    }

    /* Create and launch dgram receiver */

    if (pthread_create(&reply_sender, NULL,
                       launch_arp_sender,
                       (void *)&reply_sender_args) < 0)
    {
        rc = errno;
        TEST_FAIL("%d: Failed to create reply sender",
                  __LINE__);
    }

    pthread_join(request_sender, (void **)&request_sender_rc);
    if (request_sender_rc)
        TEST_FAIL("%d: Fail to terminate request sender, %X",
                  __LINE__, request_sender_rc);

    pthread_join(reply_sender, (void **)&reply_sender_rc);
    if (reply_sender_rc)
        TEST_FAIL("%d: Fail to terminate reply sender, %X",
                  __LINE__, reply_sender_rc);

    START_ARP_SENDER(pco_tst->ta, tst_if->if_name,
                     CVT_HW_ADDR(tst_lladdr), NULL,
                     ARPOP_REQUEST,
                     CVT_PROTO_ADDR(tst_addr),
                     CVT_HW_ADDR(tst_lladdr),
                     CVT_PROTO_ADDR(iut_addr),
                     CVT_HW_ADDR(iut_lladdr), 1, NULL);
    START_ARP_FILTER_WITH_HDR(pco_tst->ta, tst_if->if_name,
                              CVT_HW_ADDR(iut_lladdr),
                              NULL,
                              ARPOP_REQUEST,
                              TAD_ETH_RECV_DEF | TAD_ETH_RECV_NO_PROMISC,
                              NULL, NULL,
                              NULL, NULL, 0, handle);
    TEST_PROVOKE_ARP_REQ(pco_tst, pco_iut, RPC_SOCK_STREAM,
                         tst_addr, iut_addr, TRUE);

    /* Stop Ethernet filter, check that no ARPs sent */
    STOP_ETH_FILTER(pco_tst->ta, handle, frames_caught);

    if (frames_caught != 0)
        TEST_FAIL("%d: Ethernet filter caught ARP packet",
                  __LINE__);

    TEST_SUCCESS;

cleanup:

    CLEANUP_CHECK_RC(tapi_tad_csap_destroy(pco_tst->ta, 0, handle));
    free(fake_addr_list);

    sockts_restart_if(pco_iut, iut_if->if_name);

    TEST_END;
}
